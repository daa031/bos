# 1. Работа с командной оболочкой и справочной системой

## что-то
```echo "hello world222" >qqq ```

```cal -3``` - календарь на 3 месяца

```ln -s l1/l2/ltext ltext_link``` - создать мягкую ссылку


## Конвейеры. Обработка текстовых файлов

```grep :/bin/bash passwd | wc -l``` - поисе строк, которые содержит passwd, результат в wc -l , она считает сколько таких строк

```cut  -d: -f1,5 pswd3 | column -ts: | sort -r | less > res``` - берем 1 и 5 столбец в pswd3, записываем в колонки, сортируем по убываению, результат направляем в res (less -n25 -какое кол-во строк) (sort -k1,1 -  текстовые данные будут отсортированы по значениям в первой колонке) ()

```cat passwd | tr ":" " " | sort -k1,1 > res``` - Вывести файл passwd в отсортированном по пользователям виде, заменив знаки двоеточия пробелами:



## работа с сетью
```ping ya.ru``` - проверка доступности домена

```curl wttr.in``` - HTTP-запросов к веб-серверам (тут запрос погоды)

```hostname -I``` - мой IP
``` curl ifconfig.me ``` -  внешний IP 

## Изучение команды find 


```find / -type f,d -name "*pass*"``` - все файлы и каталоги, имя которых содержит слово pass, поиск начните с корневого каталога.

```find / -type f,d -iname "*pass*"``` - все файлы и каталоги, имя которых содержит слово pass без учёта регистра, поиск начните с корневого каталога.

```find / -maxdepth 2 -type f,d -name "*pass*"``` - все файлы и каталоги, имя которых содержит слово pass, ограничив глубину поиска одним каталогом, поиск начните с корневого каталога.

```find /home -maxdepth 1 -type f,d -name "*.bin"```- все файлы и каталоги, имена которых оканчиваются на .bin. Поиск необходимо выполнить в каталоге /home.

```find . -type f -name '*.bak' -exec rm -f {} \;``` - все файлы (и только файлы) с расширением bak и удалите их.
``{}`` - заменяется на имя текущего найденного файла. ``rm -f`` - это команда rm с опцией -f, которая выполняет удаление файла без запроса подтверждения. ``\;`` - символ завершения команды, который указывает, что команда -exec завершилась.

```find . -type f -name '*.txt' -o -type f -name '*.sh'```- все файлы (и только файлы) с расширениями txt и sh.


```find .  -type f -exec stat -c "%n %U %G %h %s" {} \;``` -  все файлы (и только файлы) в текущем каталоге и выведите только имя файла (без каталога), владельца, группу владельца, количество жёстких ссылок на этот файл и его размер в байтах.
`%n` - имя файла.`%U` - владелец файла.`%G` - группа владельца файла.`%h` - количество жёстких ссылок на файл.`%s` - размер файла в байтах.

```find . -type d -empty```- все пустые каталоги в текущем каталоге.

```find . -type d -empty -exec rm -r {} \;```- все пустые каталоги в текущем каталоге и удалите их.

```find . -type f -empty -exec rm -f {} \;``` - Найдите и удалите все пустые файлы (и только файлы).

```find . -type f -links +0``` - Найдите все файлы (и только файлы) в текущем каталоге, на которые есть хотя бы одна жёсткая ссылка.

```sudo find /etc -not -user root``` - Найдите файлы и каталоги в каталоге /etc, не принадлежащие пользователю root.

```find . -type f -not -name '*.sh'```- Найдите все файлы (и только файлы), у которых нет расширения sh.

```find . -type f -links +2``` - Найдите все файлы (и только файлы), у которых количество жёстких ссылок более двух.

```find /usr/bin -type f -atime +90``` - Найдите все файлы (и только файлы) в каталоге /usr/bin, последний доступ к которым осуществлялся более трёх месяцев назад.

```find /usr/bin /usr/share -type f -ctime -10``` - Найдите все файлы (и только файлы) в каталогах /usr/bin и /usr/share, созданные или изменённые в течении последних 10 дней.

```find /usr/bin -type f \( -perm -4000 -o -perm -2000 \) ``` - Найдите все файлы (и только файлы) в каталоге /usr/bin с установленным флагом suid/sgid.



```find . -type f -name "*.txt" -exec cat {} \; | wc -l``` - Найдите все файлы (и только файлы) с расширением txt и подсчитайте количество строк во всех этих файлах. ``wc -l`` - подсчитывает количество строк во всех файлах, полученных от команды cat.

```find . -type d -name ".svn" -exec rm -r {} \; -print```- Найдите все каталоги с названием .svn и удалите их, включая содержимое этих каталогов, попутно выводя список удалённых файлов на экран. ``-print`` выводит список удаленных файлов на экран.

```find . -type f -name '.sh' -exec chmod +x {} \;``` - Найдите все файлы (и только файлы) с расширением sh и добавьте им право на исполнение.

```find /etc -type f -name "*.conf" -exec du -c {} + | grep "total$" | awk '{sum += $1} END {print sum}'``` - Найдите все файлы (и только файлы) с расширением conf в каталоге /etc и подсчитайте их суммарный размер, используя команду du.


## grep:

```grep -i "ERROR" /var/log/messages``` - Из файла /var/log/messages вывести строки, содержащие ключевое слово ERROR, без учёта регистра.

```grep -icv "ERROR" /var/log/messages ``` - Из файла /var/log/messages вывести количество строк, не содержащих ключевое слово ERROR, без учёта регистра.

```grep -w "ERROR" /var/log/messages``` - Из файла /var/log/messages вывести строки, содержащие только слово ERROR целиком, с учётом регистра.


```grep -c "wheel" /etc/group``` - Вывести количество строк из файла /etc/group, совпадающих с шаблоном wheel.

```grep -r "#\!bin/bash" .``` - Найти во всех файлах из текущего каталога и вложенных подкаталогов строки, содержащие шаблон #!bin/bash. ``-r`` указывает grep выполнять рекурсивный поиск в подкаталогах начиная с текущего каталога (.). ``"#\!bin/bash"`` - это шаблон для поиска. Обратный слеш ! используется для экранирования символа !, так как ! является специальным символом в командной строке.

``grep -r -A 10 "#\!bin/bash" .``
Изменить предыдущую команду таким образом, чтобы она выводила дополнительные 10 строк после каждого найденного шаблона. `-r` указывает grep выполнять рекурсивный поиск в подкаталогах начиная с текущего каталога (.).`-A 10` указывает grep вывести 10 строк после каждого найденного шаблона.

```grep -r --color=auto -w "echo" *.sh ``` - Найти во всех файлах с расширением sh из текущего каталога и вложенных подкаталогов строки, содержащие слово echo целиком. В выводе команды grep найденные слова выделите цветом.``-r`` указывает grep выполнять рекурсивный поиск в подкаталогах.``--color=auto`` автоматически выделяет найденные слова цветом в выводе.``-w`` указывает grep искать слово "echo" целиком (без частичных совпадений).``*.sh`` означает, что поиск будет выполнен только в файлах с расширением ".sh" в текущем каталоге и его подкаталогах.


# 2 Изучение сценариев Bash 

- 1.2. Вывести количество файлов в домашнем каталоге, которые заканчиваются на .txt. Создайте несколько таких файлов для тестирования.
```bash
#!bin/bash
find . -type f -name "*.txt" | wc -l
```

- 1.3. Вывести текущие переменные окружения в отсортированном по алфавиту порядке.
```bash
#!bin/bash
env | sort
```

- 1.4. Разработать программу "Good morning", которая: Пожелает пользователю доброго утра. Выведет текущее время и календарь на текущий месяц. Выведет список дел из файла TODO домашнего каталога пользователя.
```bash
#!bin/bash
echo "Good morning"
date 
cal
cat TOdo
```

- 1.5. Найти и вывести пути до файлов из каталога /usr (включая подкаталоги), размер которых больше 20 Мб. Подсказка: man find.
```bash
#!bin/bash
find /usr -type f -size +20M
```

- 1.6. Подсчитать количество файлов, количество скрытых файлов в домашнем каталоге текущего пользователя и вывести результат в формате:
```bash
#!/bin/bash
user=$(whoami)
home_dir="/home/$user"
files_count=$(find "$home_dir" -type f | wc -l)
hidden_count=$(find "$home_dir" -type f -name ".*" | wc -l)
echo "Домашний каталог пользователя"
echo "$user"
echo "содержит обычных файлов"
echo "$files_count"
echo "скрытых файлов"
echo "hidden_count"
```
- 1.7. Вывести на экран дату, время, список активных пользователей в системе на данный момент, время работы системы с момента последней перезагрузки.
```bash
#!bin/bash
date
who
uptime
```

- 1.8. Вывести количество процессов, запущенных от имени текущего и от имени пользователя root в формате:

```bash
#!/bin/bash

user_processes=$(ps -U daa031 -u daa031 | wc -l)
root_processes=$(ps -U root -u root | wc -l)

echo "Процессов пользователя: daa031"
echo "$user_processes"
echo "Процессов пользователя root:"
echo "$root_processes"
```

- 1.9. Найти и вывести 5 процессов, потребляющих больше всего памяти в системе. Подсказка: man ps
```bash
#!/bin/bash
ps aux --sort=-%mem | head -n 6
```


- 1.10. Вывести файлы и каталоги из домашнего каталога пользователя, упорядочив их по размеру. Подсказка: использовать команды du и sort.
```bash
#!/bin/bash
du -h ~/ | sort -rh
```
``du -h ~/`` вычисляет размер всех файлов и каталогов в домашнем каталоге пользователя (~/) и использует опцию -h для вывода размеров в человекочитаемом формате.
``sort -rh`` сортирует результаты в убывающем порядке (-r), учитывая числа и числовые приставки (например, "M" для мегабайт), исходя из размера.

- 1.11. Разработать сценарий, который выводит файлы из текущего каталога в следующем порядке:

```bash
#!/bin/bash
# Вывести каталоги
echo "Каталоги:"
find . -maxdepth 1 -type d -exec ls -ld {} \; | sed '1d'
# Вывести обычные файлы
echo "Обычные файлы:"
find . -maxdepth 1 -type f -exec ls -l {} \; | sed '1d'
# Вывести символьные ссылки
echo "Символьные ссылки:"
find . -maxdepth 1 -type l -exec ls -l {} \; | sed '1d'
# Вывести символьные устройства
echo "Символьные устройства:"
find . -maxdepth 1 -type c -exec ls -l {} \; | sed '1d'
# Вывести блочные устройства
echo "Блочные устройства:"
find . -maxdepth 1 -type b -exec ls -l {} \; | sed '1d'
```








## 3.2. Перенаправление стандартного ввода/вывода================
```bash
> - записать стандартного вывод (stdout) в файл (содержимое файла будет безвозвратно утеряно)
1> - полностью аналогично предыдущему
2> - аналогично, но для вывода ошибок (stderr)
&> - аналогично, но для двух стандартных выводов сразу - stderr и stdout
>> - дописать стандартный вывод (stdout) в файл (содержимое файла будет сохранено)
2>> - аналогично, но для stderr
&>> - аналогично, но для двух стандартных выводов сразу - stderr и stdout
< file - перенаправить файл в стандартный ввод (stdin)
> &2 - всё, что программа выводит в stdout, будет перенаправлено в stderr
ls | wc - перенаправляет stdout ls в stdin wc
ls |& wc - перенаправляет stderr и stdout ls в stdin wc
/dev/null - универсальный файл-"чёрная дыра", в неё можно отправить любой ненужный вывод
: - универсальная команда, которая не выводит ничего и всегда возвращает истинный код возврата, в неё можно отправить любой ненужный вывод
```

-  создайте в домашнем каталоге файл numbers.txt, в который запишите 10 000 натуральных чисел (см. команду seq);
```bash
seq 10000 > numbers.txt
```
- создайте в домашнем каталоге файл users.txt, в который запишите имена всех пользователей системы (используйте cut и /etc/passwd);
```bash
cut -d: -f1 passwd > users.txt
```
- создайте в домашнем каталоге файл bash.txt, в который запишите содержимое двоичного файла /bin/bash в текстовом виде (используйте od);
```bash
od -t x1 -A n /bin/bash > bash.txt
```
- создайте в домашнем каталоге файл services.txt, который будет идентичным файлу /etc/services (скопировать файл с новым именем).
```bash
cp /etc/services services.txt
```






2.1. Разработать сценарий, который ведёт в файле /tmp/run.log последовательный журнал запусков:

в конец журнала добавляет строку с датой и временем запуска сценария (используйте команду date для фиксации даты и времени запуска сценария);
в стандартный вывод (stdout) - выводит фразу "Hello, World!"
в стандартный вывод ошибок (stderr) - выводит количество предыдущих запусков программы (для этого достаточно подсчитать количество строк в журнале).
Убедиться в правильности работы программы и выводе различных сообщений в различные потоки вывода:

2.1.sh > /dev/null # должен вывести счётчик запусков, счётчик должен увеличиваться
2.1.sh 2> /dev/null # должен вывести Hello, World!

```bash
[daa031@192 2]$ micro 2.1.sh 
[daa031@192 2]$ bash 2.1.sh > null
Количество предыдущих запусков: 6
[daa031@192 2]$ bash 2.1.sh > null
Количество предыдущих запусков: 7
[daa031@192 2]$ bash 2.1.sh > null
Количество предыдущих запусков: 8
[daa031@192 2]$ bash 2.1.sh 2> null
Hello, world
[daa031@192 2]$ bash 2.1.sh 2> null
Hello, world
[daa031@192 2]$ bash 2.1.sh 2> null
Hello, world
[daa031@192 2]$ bash 2.1.sh 2> null
Hello, world
[daa031@192 2]$ bash 2.1.sh > null
Количество предыдущих запусков: 13
[daa031@192 2]$ cat null | less
[daa031@192 2]$ cat *.log | less
[daa031@192 2]$ cat 2.1.sh 
#!/bin/bash

log_file="run.log"
prev_runs=$(wc -l < "$log_file")
date >> "$log_file"
echo "Hello, world"
echo "Количество предыдущих запусков: $prev_runs" >&2
```

2.2. Разработать сценарий, который запускает сценарий, разработанный в предыдущем задании, а также открывает журнал запусков предыдущего сценария в программе less.
```bash
#!/bin/bash
./2.1.sh
less run.log
```

2.3. Разработать сценарий, который для bash.txt (созданного ранее): сохранит строки, которые содержат сочетание символов 000000 в файл /tmp/zeros; сохранит строки, которые не содержат сочетания символов 000000 - в файл /tmp/nozeros; выведет 10 первых и 10 последних строк от каждого из файлов /tmp/zeros и /tmp/nozeros
```bash
#!/bin/bash
input_file="bash.txt"
zeros_file="zeros"
nozeros_file="nozeros"
grep "000000" "$input_file" > "$zeros_file"
grep -v "000000" "$input_file" > "$nozeros_file"
echo "Первые 10 строк из $zeros_file:"
head -n 10 "$zeros_file"
echo "Последние 10 строк из $zeros_file:"
tail -n 10 "$zeros_file"
echo "Первые 10 строк из $nozeros_file:"
head -n 10 "$nozeros_file"
echo "Последние 10 строк из $nozeros_file:"
tail -n 10 "$nozeros_file"
```


2.4. Разработать сценарий, который считывает построчно стандартный ввод и выводит только те строки, которые содержат слово bin целиком в стандартный вывод ошибок. Для проверки сценария используйте конвейер с командой 'ls /.
```bash
#!/bin/bash


while read -r line; do

  if [[ "$line" == *'bin'* ]]; then

    echo "$line" >&2
  fi
done
```





2.5. Разработать сценарий, который для всех файлов с расширением txt в домашнем каталоге пользователя:

выведет список таких файлов;
выведет суммарный размер в байтах и строках для файлов с расширением txt.
Подсказка. Для решении этой задачи создайте временный файл в каталоге /tmp, по окончании работы сценария удалите его.

```bash
#!/bin/bash
# Путь к домашнему каталогу пользователя
home_directory="$HOME"
# Создаем временный файл для хранения списка файлов
temp_file=$(mktemp /tmp/txt_files.XXXXXX)
# Используем find для поиска файлов с расширением ".txt" в домашнем каталоге
find "$home_directory" -type f -name "*.txt" > "$temp_file"
# Выводим список найденных файлов
echo "Список файлов с расширением .txt:"
cat "$temp_file"
# Используем wc для подсчета строк в найденных файлах
total_lines=$(cat "$temp_file" | xargs wc -l | awk '{total += $1} END {print total}')
# Используем du для подсчета суммарного размера в байтах
total_size=$(cat "$temp_file" | xargs du -cb | tail -n 1 | cut -f1)
# Выводим суммарный размер и количество строк
echo "Суммарный размер файлов (в байтах): $total_size"
echo "Суммарное количество строк: $total_lines"
# Удаляем временный файл
rm "$temp_file"
```










2.6. Разработать сценарий поиска дубликатов файлов (файлы, с одинаковым содержимым), который выводит сначала количество дубликатов, затем имя файла. Файлы без дубликатов выводиться не должны.

Для подготовки выполните команды:

mkdir dups
cd dups
touch {1..3}.txt
echo 4 > 4.txt
echo 4 > 5.txt
echo 6 > 6.txt
Подсказка. Наиболее эффективным методом поиска дубликатов является вычисление их хэш-суммы с последующей их обработкой. У файлов-дубликатов хэш-суммы будут одинаковыми. Используйте команды sort, uniq, grep, tr, cut. Изучите как команды sort и uniq работают с колонками.

md5sum *.txt | ???? -k? | ???? -? -? ?? | ... | ... | ...
Должен получиться вывод:

2	4.txt
3	1.txt


Для поиска дубликатов файлов по их хэш-суммам и вывода количества дубликатов с их именами, вы можете воспользоваться следующим скриптом:
```bash
#!/bin/bash

# Путь к каталогу, где находятся файлы
directory="dups"

# Вычисляем хэш-суммы для файлов в каталоге и сортируем результат
md5sum "$directory"/*.txt | sort > md5sums.txt

# Используем команды sort, uniq и awk для подсчета дубликатов и вывода их имен
cat md5sums.txt | cut -f1 -d' ' | uniq -d | while read -r hash; do
  count=$(grep -c "$hash" md5sums.txt)
  if [ "$count" -gt 1 ]; then
    grep "$hash" md5sums.txt | head -n "$count" | cut -f2 -d' ' | tr '\n' '\t'
    echo "$count"
  fi
done

# Удаляем временный файл
rm md5sums.txt
Сохраните этот скрипт, например, как find_duplicates.sh, и дайте ему права на выполнение с помощью chmod +x find_duplicates.sh. Затем запустите его:

bash
Copy code
./find_duplicates.sh
Скрипт выполнит следующие действия:

Вычисляет хэш-суммы для файлов в указанном каталоге (dups) и сортирует их в файл md5sums.txt.

Использует команды cut, uniq и awk для подсчета дубликатов хэш-сумм и вывода их имен, а также количества дубликатов.

Удаляет временный файл md5sums.txt.
```



- с сайта  {https://learnxinyminutes.com/docs/ru-ru/bash-ru}
```bash 
# Отдельные команды начинаются с новой строки или разделяются точкой с запятой:
echo 'Это первая строка'; echo 'Это вторая строка'

# Вот так объявляется переменная:
VARIABLE="Просто строка"

# Использование переменой:
echo $VARIABLE # => Просто строка
echo "$VARIABLE" # => Просто строка
echo '$VARIABLE' # => $Variable

# Раскрытие параметров ${ }:
echo ${Variable} # => Просто строка
# Это простое использование раскрытия параметров
# Раскрытие параметров получает значение переменной.
# Оно «раскрывает», или печатает это значение.


# Взять подстроку из переменной
LENGTH=7
echo ${VARIABLE:0:LENGTH} # => Просто 
# Это выражение вернёт только первые 7 символов переменной VARIABLE
echo ${Variable: -5} # => трока
# Вернёт последние 5 символов (обратите внимание на пробел перед «-5»)

# Длина строки
echo ${#Variable} # => 13



# Значение переменной по умолчанию
echo ${FOO:-"ЗначениеПоУмолчаниюЕслиFooПустаИлиНеНайдена"}
# => ЗначениеПоУмолчаниюЕслиFooПустаИлиНеНайдена
# Это сработает при отсутствующем значении (FOO=) и пустой строке (FOO="");
# ноль (FOO=0) вернёт 0.
# Заметьте, что в любом случае это лишь вернёт значение по умолчанию,
# а значение самой переменной FOO не изменится.


# Объявить массив из 6 элементов
array0=(один два три четыре пять шесть)
# Вывести первый элемент
echo $array0 # => "один"
# Вывести первый элемент
echo ${array0[0]} # => "один"
# Вывести все элементы
echo ${array0[@]} # => "один два три четыре пять шесть"
# Вывести число элементов
echo ${#array0[@]} # => "6"
# Вывести число символов в третьем элементе
echo ${#array0[2]} # => "3"
# Вывести 2 элемента, начиная с четвёртого
echo ${array0[@]:3:2} # => "четыре пять"
# Вывести все элементы, каждый на своей строке
for i in "${array0[@]}"; do
    echo "$i"
done

# Раскрытие скобок { }
# Используется для создания произвольных строк
echo {1..10} # => 1 2 3 4 5 6 7 8 9 10
echo {a..z} # => a b c d e f g h i j k l m n o p q r s t u v w x y z
# Выведет диапазон от начального до конечного значения


# Встроенные переменные:
# В bash есть полезные встроенные переменные, например
echo "Значение, возвращённое последней программой: $?"
echo "Идентификатор процесса скрипта: $$"
echo "Число аргументов, переданных скрипту: $#"
echo "Все аргументы, переданные скрипту: $@"
echo "Аргументы скрипта, распределённые по отдельным переменным: $1 $2..



# Текущая директория доступна по команде `pwd`.
# `pwd` расшифровывается как «print working directory», т.е.
# «напечатать рабочую директорию».
# Мы также можем использовать встроенную переменную `$PWD`.
# Заметьте, следующие выражения эквивалентны:
echo "Я в $(pwd)" # выполняет `pwd` и раскрывает вывод
echo "Я в $PWD" # раскрывает переменную


# Чтение аргументов с устройства ввода:
echo "Как Вас зовут?"
read NAME # Обратите внимание, что нам не нужно определять новую переменную
echo Привет, $NAME!

# У нас есть обычная структура if:
# наберите 'man test' для получения подробной информации о форматах условия
if [ $NAME != $USER ]
then
    echo "Имя не совпадает с именем пользователя"
else
    echo "Имя совпадает с именем пользователя"
fi
# Истинно, если значение $Name не совпадает с текущим именем пользователя


# Также есть условное исполнение
echo "Исполнится всегда" || echo "Исполнится, если первая команда завершится ошибкой"
# => Исполнится всегда
echo "Исполнится всегда" && echo "Исполнится, если первая команда выполнится удачно"


# Чтобы использовать && и || в выражениях if, нужно несколько пар скобок:
if [ $NAME == "Стив" ] && [ $AGE -eq 15 ]
then
    echo "Исполнится, если $NAME равно Стив И $AGE равно 15."
fi



# Есть ещё оператор «=~», который проверяет строку
# на соответствие регулярному выражению:
Email=me@example.com
if [[ "$Email" =~ [a-z]+@[a-z]{2,}\.(com|net|org) ]]
then
    echo "адрес корректный!"
fi
# Обратите внимание, что =~ работает только внутри
# двойных квадратных скобок [[ ]],
# которые несколько отличаются от одинарных скобок [ ].


# Результат предыдущей команды может быть направлен на вход следующей.
# Команда grep фильтрует ввод по шаблону.
# Так мы можем просмотреть только *.txt-файлы в текущей директории:
ls -l | grep "\.txt"

# Для вывода файлов в стандартный поток используйте `cat`:
cat file.txt

# С помощью `cat` мы также можем читать файлы:
Contents=$(cat file.txt)
echo "НАЧАЛО ФАЙЛА\n$Contents\nКОНЕЦ ФАЙЛА" # «\n» выводит символ перевода на новую строку
# => НАЧАЛО ФАЙЛА
# => [Содержимое file.txt]
# => КОНЕЦ ФАЙЛА


# Для работы по директориям используйте субоболочки
(echo "Сначала я здесь: $PWD") && (cd someDir; echo "А теперь я тут: $PWD")
pwd # всё ещё в первой директории



# Вы также можете определять функции
# Определение:
function foo ()
{
    echo "Аргументы работают так же, как и аргументы скрипта: $@"
    echo "И так: $1 $2..."
    echo "Это функция"
    return 0
}
# Вызовем функцию `foo` с двумя аргументами, arg1 и arg2:
foo arg1 arg2
# => Аргументы работают так же, как и аргументы скрипта: arg1 arg2
# => И так: arg1 arg2...
# => Это функция
```

# 3. Аргументы командной строки и переменные


