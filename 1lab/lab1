[daa031@fedora 1lab]$ echo "hello world"
hello world
[daa031@fedora 1lab]$ echo "hello world222" > 
pswd  qqq   q.sh  
[daa031@fedora 1lab]$ echo "hello world222" >qqq 
[daa031@fedora 1lab]$ cat qqq
hello world222
[daa031@fedora 1lab]$ date
Ср 27 сен 2023 15:34:15 EDT
[daa031@fedora 1lab]$ cal
    Сентябрь 2023   
Пн Вт Ср Чт Пт Сб Вс
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30   
                    
[daa031@fedora 1lab]$ man cal
[daa031@fedora 1lab]$ cal -3
     Август 2023          Сентябрь 2023         Октябрь 2023    
Пн Вт Ср Чт Пт Сб Вс  Пн Вт Ср Чт Пт Сб Вс  Пн Вт Ср Чт Пт Сб Вс
    1  2  3  4  5  6               1  2  3                     1
 7  8  9 10 11 12 13   4  5  6  7  8  9 10   2  3  4  5  6  7  8
14 15 16 17 18 19 20  11 12 13 14 15 16 17   9 10 11 12 13 14 15
21 22 23 24 25 26 27  18 19 20 21 22 23 24  16 17 18 19 20 21 22
28 29 30 31           25 26 27 28 29 30     23 24 25 26 27 28 29
                                            30 31               
[daa031@fedora 1lab]$ ls
pswd  qqq  q.sh
[daa031@fedora 1lab]$ ls *q
qqq
[daa031@fedora 1lab]$ ls q*
qqq  q.sh
[daa031@fedora 1lab]$ touch qwe wer
[daa031@fedora 1lab]$ ls [we]*
wer
[daa031@fedora 1lab]$ man wc
[daa031@fedora 1lab]$ wc 
pswd  qqq   q.sh  qwe   wer   
[daa031@fedora 1lab]$ wc pswd 
  78   78 3582 pswd
[daa031@fedora 1lab]$ man ln
[daa031@192 1lab]$ ln -s l1/l2/ltext ltext_link
[daa031@192 1lab]$ ls
l1  lab1  ltext_link  pswd  qqq  q.sh  qwe  wer
[daa031@192 1lab]$ ln  l1/l2/ltext ltext_link_hard







grep :/bin/bash /etc/passwd | wc -l

[daa031@192 1lab]$ cut  -d: -f1,5 pswd3 | column -ts: | sort -r | less > res
[daa031@192 1lab]$ cat res | less



[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | less
[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | less
[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | less
[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | less 25
25: Нет такого файла или каталога
[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | less -n 25
25: Нет такого файла или каталога
[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | less -n25
[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | less -n5
[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | less -n=5
There is no -= option ("less --help" for help)
Press RETURN to continue 
[daa031@192 1lab]$ 
[daa031@192 1lab]$ man less
[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | less -n 5 > res2
[daa031@192 1lab]$ ls
l1  lab1  ltext_link  ltext_link_hard  pswd  pswd2  pswd3  qqq  q.sh  qwe  res  res2  wer
[daa031@192 1lab]$ micro res2
[daa031@192 1lab]$ rpm -qa --qf '%{NAME}: %{SIZE}\n' | sort -rn -k2,2 | head -n 7 > res2
[daa031@192 1lab]$ micro res2


[daa031@192 1lab]$ cut  -d: -f1,5 pswd3 | column -ts: | sort -r | less > res
[daa031@192 1lab]$ cat /etc/passwd | tr ":" " " | sort -k1,1 > res4.9
[daa031@192 1lab]$ cat 4.9

cut -d: -f1,7 /etc/passwd | sort -k1,1 | column -t


[daa031@192 1lab]$ # работа с сетью
[daa031@192 1lab]$ # 5.1. Проверьте доступность сети командой ping.
[daa031@192 1lab]$ ping ya.ru
PING ya.ru (77.88.55.242) 56(84) bytes of data.
64 bytes from ya.ru (77.88.55.242): icmp_seq=1 ttl=53 time=11.9 ms
64 bytes from ya.ru (77.88.55.242): icmp_seq=2 ttl=53 time=13.6 ms
64 bytes from ya.ru (77.88.55.242): icmp_seq=3 ttl=53 time=21.3 ms
64 bytes from ya.ru (77.88.55.242): icmp_seq=4 ttl=53 time=13.7 ms
^C
--- ya.ru ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3005ms
rtt min/avg/max/mdev = 11.897/15.117/21.303/3.641 ms
[daa031@192 1lab]$ curl wttr.in
Weather report: Moscow, Russia

      \   /     Clear
       .-.      16 °C          
    ― (   ) ―   ↗ 15 km/h      
       `-’      10 km          
      /   \     0.0 mm         
                                                       ┌─────────────┐                                                       
┌──────────────────────────────┬───────────────────────┤  Thu 28 Sep ├───────────────────────┬──────────────────────────────┐
│            Morning           │             Noon      └──────┬──────┘     Evening           │             Night            │
├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤
│     \   /     Sunny          │     \   /     Sunny          │     \   /     Sunny          │     \   /     Clear          │
│      .-.      16 °C          │      .-.      20 °C          │      .-.      18 °C          │      .-.      17 °C          │
│   ― (   ) ―   ↗ 12-15 km/h   │   ― (   ) ―   ↗ 15-17 km/h   │   ― (   ) ―   ↗ 13-22 km/h   │   ― (   ) ―   → 12-21 km/h   │
│      `-’      10 km          │      `-’      10 km          │      `-’      10 km          │      `-’      10 km          │
│     /   \     0.0 mm | 0%    │     /   \     0.0 mm | 0%    │     /   \     0.0 mm | 0%    │     /   \     0.0 mm | 0%    │
└──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘
                                                       ┌─────────────┐                                                       
┌──────────────────────────────┬───────────────────────┤  Fri 29 Sep ├───────────────────────┬──────────────────────────────┐
│            Morning           │             Noon      └──────┬──────┘     Evening           │             Night            │
├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤
│     \   /     Sunny          │     \   /     Sunny          │     \   /     Sunny          │     \   /     Clear          │
│      .-.      18 °C          │      .-.      22 °C          │      .-.      19 °C          │      .-.      17 °C          │
│   ― (   ) ―   → 9-11 km/h    │   ― (   ) ―   → 10-12 km/h   │   ― (   ) ―   ↗ 8-14 km/h    │   ― (   ) ―   ↗ 8-15 km/h    │
│      `-’      10 km          │      `-’      10 km          │      `-’      10 km          │      `-’      10 km          │
│     /   \     0.0 mm | 0%    │     /   \     0.0 mm | 0%    │     /   \     0.0 mm | 0%    │     /   \     0.0 mm | 0%    │
└──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘
                                                       ┌─────────────┐                                                       
┌──────────────────────────────┬───────────────────────┤  Sat 30 Sep ├───────────────────────┬──────────────────────────────┐
│            Morning           │             Noon      └──────┬──────┘     Evening           │             Night            │
├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤
│     \   /     Sunny          │     \   /     Sunny          │     \   /     Sunny          │     \   /     Clear          │
│      .-.      17 °C          │      .-.      22 °C          │      .-.      19 °C          │      .-.      17 °C          │
│   ― (   ) ―   ↗ 13-16 km/h   │   ― (   ) ―   ↗ 15-18 km/h   │   ― (   ) ―   ↗ 10-19 km/h   │   ― (   ) ―   ↗ 13-23 km/h   │
│      `-’      10 km          │      `-’      10 km          │      `-’      10 km          │      `-’      10 km          │
│     /   \     0.0 mm | 0%    │     /   \     0.0 mm | 0%    │     /   \     0.0 mm | 0%    │     /   \     0.0 mm | 0%    │
└──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘

Follow @igor_chubin for wttr.in updates
[daa031@192 1lab]$ curl ya.ru
[daa031@192 1lab]$ hostname -I
192.168.1.10 
[daa031@192 1lab]$ curl ifconfig.me
109.252.151.170[daa031@192 1lab]$ 




Изучение команды find 

1)Найдите все файлы и каталоги, имя которых содержит слово pass, поиск начните с корневого каталога.
[daa031@192 test_finding]$ find / -type f,d -name "*pass*"

2)Найдите все файлы и каталоги, имя которых содержит слово pass без учёта регистра, поиск начните с корневого каталога.
[daa031@192 test_finding]$ find / -type f,d -iname "*pass*"

3)Найдите все файлы и каталоги, имя которых содержит слово pass, ограничив глубину поиска одним каталогом, поиск начните с корневого каталога.
[daa031@192 test_finding]$ find / -maxdepth 2 -type f,d -name "*pass*"

4)Найдите все файлы и каталоги, имена которых оканчиваются на .bin. Поиск необходимо выполнить в каталоге /home.
[daa031@192 test_finding]$ find /home -maxdepth 1 -type f,d -name "*.bin"

5)Найдите все файлы (и только файлы) с расширением bak и удалите их.
find . -type f -name '*.bak' -exec rm -f {} \;
{} - заменяется на имя текущего найденного файла.
rm -f - это команда rm с опцией -f, которая выполняет удаление файла без запроса подтверждения.
\; - символ завершения команды, который указывает, что команда -exec завершилась.


6)Найдите все файлы (и только файлы) с расширениями txt и sh.
find . -type f -name '*.txt' -o -type f -name '*.sh'


7)Найдите все файлы (и только файлы) в текущем каталоге и выведите только имя файла (без каталога), владельца, группу владельца, количество жёстких ссылок на этот файл и его размер в байтах.
find .  -type f -exec stat -c "%n %U %G %h %s" {} \;
%n - имя файла.
%U - владелец файла.
%G - группа владельца файла.
%h - количество жёстких ссылок на файл.
%s - размер файла в байтах.


8)Найдите все пустые каталоги в текущем каталоге.
find . -type d -empty

9)Найдите все пустые каталоги в текущем каталоге и удалите их.
find . -type d -empty -exec rm -r {} \;

10)Найдите и удалите все пустые файлы (и только файлы).
find . -type f -empty -exec rm -f {} \;

11)Найдите все файлы (и только файлы) в текущем каталоге, на которые есть хотя бы одна жёсткая ссылка.
find . -type f -links +0

12)Найдите файлы и каталоги в каталоге /etc, не принадлежащие пользователю root.
sudo find /etc -not -user root

13)Найдите все файлы (и только файлы), у которых нет расширения sh.
find . -type f -not -name '*.sh'

14)Найдите все файлы (и только файлы), у которых количество жёстких ссылок более двух.
find . -type f -links +2

15)Найдите все файлы (и только файлы) в каталоге /usr/bin, последний доступ к которым осуществлялся более трёх месяцев назад.
find /usr/bin -type f -atime +90

16)Найдите все файлы (и только файлы) в каталогах /usr/bin и /usr/share, созданные или изменённые в течении последних 10 дней.
find /usr/bin /usr/share -type f -ctime -10

17)Найдите и удалите все файлы (и только файлы) в каталоге /tmp, которые не менялись более двух недель.

18)Найдите все файлы (и только файлы) в каталоге /usr/bin с установленным флагом suid/sgid.
find /usr/bin -type f \( -perm -4000 -o -perm -2000 \)




19)Найдите все файлы (и только файлы) с расширением txt и подсчитайте количество строк во всех этих файлах.
find . -type f -name "*.txt" -exec cat {} \; | wc -l
| - это символ перенаправления вывода, который передает вывод команды cat на вход команды wc.
wc -l - подсчитывает количество строк во всех файлах, полученных от команды cat.

20)Найдите все каталоги с названием .svn и удалите их, включая содержимое этих каталогов, попутно выводя список удалённых файлов на экран.
find . -type d -name ".svn" -exec rm -r {} \; -print
-print выводит список удаленных файлов на экран.

21)Найдите все файлы (и только файлы) с расширением sh и добавьте им право на исполнение.
find . -type f -name '.sh' -exec chmod +x {} \;

22)Найдите все файлы (и только файлы) с расширением conf в каталоге /etc и подсчитайте их суммарный размер, используя команду du.
find /etc -type f -name "*.conf" -exec du -c {} + | grep "total$" | awk '{sum += $1} END {print sum}'


Используя команду grep:

1)Из файла /var/log/messages вывести строки, содержащие ключевое слово ERROR, без учёта регистра.
grep -i "ERROR" /var/log/messages

2)Из файла /var/log/messages вывести количество строк, не содержащих ключевое слово ERROR, без учёта регистра.
grep -icv "ERROR" /var/log/messages

3)Из файла /var/log/messages вывести строки, содержащие только слово ERROR целиком, с учётом регистра.
grep -w "ERROR" /var/log/messages

4)Вывести количество строк из файла /etc/group, совпадающих с шаблоном wheel.
grep -c "wheel" /etc/group

5)Найти во всех файлах из текущего каталога и вложенных подкаталогов строки, содержащие шаблон #!bin/bash.
grep -r "#\!bin/bash" .
-r указывает grep выполнять рекурсивный поиск в подкаталогах начиная с текущего каталога (.).
"#\!bin/bash" - это шаблон для поиска. Обратный слеш ! используется для экранирования символа !, так как ! является специальным символом в командной строке.

6)Изменить предыдущую команду таким образом, чтобы она выводила дополнительные 10 строк после каждого найденного шаблона.
grep -r -A 10 "#\!bin/bash" .
-r указывает grep выполнять рекурсивный поиск в подкаталогах начиная с текущего каталога (.).
-A 10 указывает grep вывести 10 строк после каждого найденного шаблона.

7)Найти во всех файлах с расширением sh из текущего каталога и вложенных подкаталогов строки, содержащие слово echo целиком. В выводе команды grep найденные слова выделите цветом.
grep -r --color=auto -w "echo" *.sh
-r указывает grep выполнять рекурсивный поиск в подкаталогах.
--color=auto автоматически выделяет найденные слова цветом в выводе.
-w указывает grep искать слово "echo" целиком (без частичных совпадений).
*.sh означает, что поиск будет выполнен только в файлах с расширением ".sh" в текущем каталоге и его подкаталогах.

8)Измените предыдущую команду таким образом, чтобы команда grep отображала также имя файла и номер строки, в которой было обнаружено совпадение с шаблоном.
-r указывает grep выполнять рекурсивный поиск в подкаталогах.
-H заставляет grep выводить имя файла, даже если поиск осуществляется только в одном файле.
-n заставляет grep выводить номера строк.
--color=auto автоматически выделяет найденные слова цветом в выводе.
-w указывает grep искать слово "echo" целиком (без частичных совпадений).
*.sh означает, что поиск будет выполнен только в файлах с расширением ".sh" в текущем каталоге и его подкаталогах.

Поиск по тексту: grep позволяет искать строки, содержащие определенный текст или шаблон. Простейшая форма использования выглядит так: grep "шаблон" файл.

Игнорирование регистра: С опцией -i можно указать grep игнорировать регистр букв при поиске. Например, grep -i "error" файл найдет как "error", так и "Error" и "ERROR".

Регулярные выражения: grep поддерживает регулярные выражения для более сложного и гибкого поиска. Например, grep "pat*rn" найдет строки, содержащие "pattern", "patrn", "patern", и так далее.

Вывод номеров строк: С опцией -n, grep будет выводить номера строк, в которых найден шаблон. Например, grep -n "error" файл выведет строки с номерами.

Вывод только совпадений: С опцией -o, grep выведет только сами совпадения, а не строки, содержащие их.

Поиск в нескольких файлах: grep может искать в нескольких файлах, перечисленных после команды. Например, grep "шаблон" файл1 файл2 файл3.

Рекурсивный поиск: С опцией -r (или -R), grep может рекурсивно искать во всех файлах в указанном каталоге и его подкаталогах.

Исключение файлов: С опцией --exclude или --exclude-dir, можно исключить определенные файлы или каталоги из поиска.

Инвертированный поиск: С опцией -v, grep будет выводить строки, которые НЕ содержат указанный шаблон.














--------------------Изучение сценариев Bash--------------------
# Отдельные команды начинаются с новой строки или разделяются точкой с запятой:
echo 'Это первая строка'; echo 'Это вторая строка'

# Вот так объявляется переменная:
VARIABLE="Просто строка"

# Использование переменой:
echo $VARIABLE # => Просто строка
echo "$VARIABLE" # => Просто строка
echo '$VARIABLE' # => $Variable

# Раскрытие параметров ${ }:
echo ${Variable} # => Просто строка
# Это простое использование раскрытия параметров
# Раскрытие параметров получает значение переменной.
# Оно «раскрывает», или печатает это значение.


# Взять подстроку из переменной
LENGTH=7
echo ${VARIABLE:0:LENGTH} # => Просто 
# Это выражение вернёт только первые 7 символов переменной VARIABLE
echo ${Variable: -5} # => трока
# Вернёт последние 5 символов (обратите внимание на пробел перед «-5»)

# Длина строки
echo ${#Variable} # => 13



# Значение переменной по умолчанию
echo ${FOO:-"ЗначениеПоУмолчаниюЕслиFooПустаИлиНеНайдена"}
# => ЗначениеПоУмолчаниюЕслиFooПустаИлиНеНайдена
# Это сработает при отсутствующем значении (FOO=) и пустой строке (FOO="");
# ноль (FOO=0) вернёт 0.
# Заметьте, что в любом случае это лишь вернёт значение по умолчанию,
# а значение самой переменной FOO не изменится.


# Объявить массив из 6 элементов
array0=(один два три четыре пять шесть)
# Вывести первый элемент
echo $array0 # => "один"
# Вывести первый элемент
echo ${array0[0]} # => "один"
# Вывести все элементы
echo ${array0[@]} # => "один два три четыре пять шесть"
# Вывести число элементов
echo ${#array0[@]} # => "6"
# Вывести число символов в третьем элементе
echo ${#array0[2]} # => "3"
# Вывести 2 элемента, начиная с четвёртого
echo ${array0[@]:3:2} # => "четыре пять"
# Вывести все элементы, каждый на своей строке
for i in "${array0[@]}"; do
    echo "$i"
done

# Раскрытие скобок { }
# Используется для создания произвольных строк
echo {1..10} # => 1 2 3 4 5 6 7 8 9 10
echo {a..z} # => a b c d e f g h i j k l m n o p q r s t u v w x y z
# Выведет диапазон от начального до конечного значения


# Встроенные переменные:
# В bash есть полезные встроенные переменные, например
echo "Значение, возвращённое последней программой: $?"
echo "Идентификатор процесса скрипта: $$"
echo "Число аргументов, переданных скрипту: $#"
echo "Все аргументы, переданные скрипту: $@"
echo "Аргументы скрипта, распределённые по отдельным переменным: $1 $2..



# Текущая директория доступна по команде `pwd`.
# `pwd` расшифровывается как «print working directory», т.е.
# «напечатать рабочую директорию».
# Мы также можем использовать встроенную переменную `$PWD`.
# Заметьте, следующие выражения эквивалентны:
echo "Я в $(pwd)" # выполняет `pwd` и раскрывает вывод
echo "Я в $PWD" # раскрывает переменную


# Чтение аргументов с устройства ввода:
echo "Как Вас зовут?"
read NAME # Обратите внимание, что нам не нужно определять новую переменную
echo Привет, $NAME!

# У нас есть обычная структура if:
# наберите 'man test' для получения подробной информации о форматах условия
if [ $NAME != $USER ]
then
    echo "Имя не совпадает с именем пользователя"
else
    echo "Имя совпадает с именем пользователя"
fi
# Истинно, если значение $Name не совпадает с текущим именем пользователя


# Также есть условное исполнение
echo "Исполнится всегда" || echo "Исполнится, если первая команда завершится ошибкой"
# => Исполнится всегда
echo "Исполнится всегда" && echo "Исполнится, если первая команда выполнится удачно"


# Чтобы использовать && и || в выражениях if, нужно несколько пар скобок:
if [ $NAME == "Стив" ] && [ $AGE -eq 15 ]
then
    echo "Исполнится, если $NAME равно Стив И $AGE равно 15."
fi



# Есть ещё оператор «=~», который проверяет строку
# на соответствие регулярному выражению:
Email=me@example.com
if [[ "$Email" =~ [a-z]+@[a-z]{2,}\.(com|net|org) ]]
then
    echo "адрес корректный!"
fi
# Обратите внимание, что =~ работает только внутри
# двойных квадратных скобок [[ ]],
# которые несколько отличаются от одинарных скобок [ ].


# Результат предыдущей команды может быть направлен на вход следующей.
# Команда grep фильтрует ввод по шаблону.
# Так мы можем просмотреть только *.txt-файлы в текущей директории:
ls -l | grep "\.txt"

# Для вывода файлов в стандартный поток используйте `cat`:
cat file.txt

# С помощью `cat` мы также можем читать файлы:
Contents=$(cat file.txt)
echo "НАЧАЛО ФАЙЛА\n$Contents\nКОНЕЦ ФАЙЛА" # «\n» выводит символ перевода на новую строку
# => НАЧАЛО ФАЙЛА
# => [Содержимое file.txt]
# => КОНЕЦ ФАЙЛА


# Для работы по директориям используйте субоболочки
(echo "Сначала я здесь: $PWD") && (cd someDir; echo "А теперь я тут: $PWD")
pwd # всё ещё в первой директории



# Вы также можете определять функции
# Определение:
function foo ()
{
    echo "Аргументы работают так же, как и аргументы скрипта: $@"
    echo "И так: $1 $2..."
    echo "Это функция"
    return 0
}
# Вызовем функцию `foo` с двумя аргументами, arg1 и arg2:
foo arg1 arg2
# => Аргументы работают так же, как и аргументы скрипта: arg1 arg2
# => И так: arg1 arg2...
# => Это функция




1.2. Вывести количество файлов в домашнем каталоге, которые заканчиваются на .txt. Создайте несколько таких файлов для тестирования.
#!bin/bash
find . -type f -name "*.txt" | wc -l





1.3. Вывести текущие переменные окружения в отсортированном по алфавиту порядке.
#!bin/bash
env | sort


1.4. Разработать программу "Good morning", которая:

Пожелает пользователю доброго утра.
Выведет текущее время и календарь на текущий месяц.
Выведет список дел из файла TODO домашнего каталога пользователя.
#!bin/bash
echo "Good morning"
date 
cal
cat TOdo


1.5. Найти и вывести пути до файлов из каталога /usr (включая подкаталоги), размер которых больше 20 Мб. Подсказка: man find.
find /usr -type f -size +20M

1.6. Подсчитать количество файлов, количество скрытых файлов в домашнем каталоге текущего пользователя и вывести результат в формате:

Домашний каталог пользователя
<User>
содержит обычных файлов:
XX
скрытых файлов:
YY

#!/bin/bash

user=$(whoami)
home_dir="/home/$user"
files_count=$(find "$home_dir" -type f | wc -l)
hidden_count=$(find "$home_dir" -type f -name ".*" | wc -l)

echo "Домашний каталог пользователя"
echo "$user"
echo "содержит обычных файлов"
echo "$files_count"
echo "скрытых файлов"
echo "hidden_count"






1.7. Вывести на экран дату, время, список активных пользователей в системе на данный момент, время работы системы с момента последней перезагрузки.

#!bin/bash

date
who
uptime





1.8. Вывести количество процессов, запущенных от имени текущего и от имени пользователя root в формате:

Процессов пользователя:
<User>
XX
Процессов пользователя root:
YY

#!/bin/bash

user_processes=$(ps -U daa031 -u daa031 | wc -l)
root_processes=$(ps -U root -u root | wc -l)

echo "Процессов пользователя: daa031"
echo "$user_processes"
echo "Процессов пользователя root:"
echo "$root_processes"


1.9. Найти и вывести 5 процессов, потребляющих больше всего памяти в системе. Подсказка: man ps
ps aux --sort=-%mem | head -n 6


1.10. Вывести файлы и каталоги из домашнего каталога пользователя, упорядочив их по размеру. Подсказка: использовать команды du и sort.
du -h ~/ | sort -rh

du -h ~/ вычисляет размер всех файлов и каталогов в домашнем каталоге пользователя (~/) и использует опцию -h для вывода размеров в человекочитаемом формате.
sort -rh сортирует результаты в убывающем порядке (-r), учитывая числа и числовые приставки (например, "M" для мегабайт), исходя из размера.







1.11. Разработать сценарий, который выводит файлы из текущего каталога в следующем порядке:

Каталоги.
Обычные файлы.
Символьные ссылки.
Символьные устройства.
Блочные устройства.
Формат вывода:

Каталоги:
drwxr-xr-x  2 root root           560 сен 13 01:34 block/
drwxr-xr-x  2 root root           120 сен 13 01:34 bsg/
drwxr-xr-x  3 root root            60 июн 19 06:41 bus/
drwxr-xr-x  2 root root          3680 сен 13 01:34 char
...
Обычные файлы:
...
Символьные ссылки:
...
Символьные устройства:
...
Блочные устройства:
...



#!/bin/bash

# Вывести каталоги
echo "Каталоги:"
find . -maxdepth 1 -type d -exec ls -ld {} \; | sed '1d'

# Вывести обычные файлы
echo "Обычные файлы:"
find . -maxdepth 1 -type f -exec ls -l {} \; | sed '1d'

# Вывести символьные ссылки
echo "Символьные ссылки:"
find . -maxdepth 1 -type l -exec ls -l {} \; | sed '1d'

# Вывести символьные устройства
echo "Символьные устройства:"
find . -maxdepth 1 -type c -exec ls -l {} \; | sed '1d'

# Вывести блочные устройства
echo "Блочные устройства:"
find . -maxdepth 1 -type b -exec ls -l {} \; | sed '1d'









=================2. Перенаправление стандартного ввода/вывода================
> - записать стандартного вывод (stdout) в файл (содержимое файла будет безвозвратно утеряно)
1> - полностью аналогично предыдущему
2> - аналогично, но для вывода ошибок (stderr)
&> - аналогично, но для двух стандартных выводов сразу - stderr и stdout
>> - дописать стандартный вывод (stdout) в файл (содержимое файла будет сохранено)
2>> - аналогично, но для stderr
&>> - аналогично, но для двух стандартных выводов сразу - stderr и stdout
< file - перенаправить файл в стандартный ввод (stdin)
> &2 - всё, что программа выводит в stdout, будет перенаправлено в stderr
ls | wc - перенаправляет stdout ls в stdin wc
ls |& wc - перенаправляет stderr и stdout ls в stdin wc
/dev/null - универсальный файл-"чёрная дыра", в неё можно отправить любой ненужный вывод
: - универсальная команда, которая не выводит ничего и всегда возвращает истинный код возврата, в неё можно отправить любой ненужный вывод



создайте в домашнем каталоге файл numbers.txt, в который запишите 10 000 натуральных чисел (см. команду seq);
[daa031@192 2]$ seq 10000 > numbers.txt

создайте в домашнем каталоге файл users.txt, в который запишите имена всех пользователей системы (используйте cut и /etc/passwd);
cut -d: -f1 passwd > users.txt
создайте в домашнем каталоге файл bash.txt, в который запишите содержимое двоичного файла /bin/bash в текстовом виде (используйте od);
od -t x1 -A n /bin/bash > bash.txt
создайте в домашнем каталоге файл services.txt, который будет идентичным файлу /etc/services (скопировать файл с новым именем).
cp /etc/services services.txt







2.1. Разработать сценарий, который ведёт в файле /tmp/run.log последовательный журнал запусков:

в конец журнала добавляет строку с датой и временем запуска сценария (используйте команду date для фиксации даты и времени запуска сценария);
в стандартный вывод (stdout) - выводит фразу "Hello, World!"
в стандартный вывод ошибок (stderr) - выводит количество предыдущих запусков программы (для этого достаточно подсчитать количество строк в журнале).
Убедиться в правильности работы программы и выводе различных сообщений в различные потоки вывода:

2.1.sh > /dev/null # должен вывести счётчик запусков, счётчик должен увеличиваться
2.1.sh 2> /dev/null # должен вывести Hello, World!


[daa031@192 2]$ micro 2.1.sh 
[daa031@192 2]$ bash 2.1.sh > null
Количество предыдущих запусков: 6
[daa031@192 2]$ bash 2.1.sh > null
Количество предыдущих запусков: 7
[daa031@192 2]$ bash 2.1.sh > null
Количество предыдущих запусков: 8
[daa031@192 2]$ bash 2.1.sh 2> null
Hello, world
[daa031@192 2]$ bash 2.1.sh 2> null
Hello, world
[daa031@192 2]$ bash 2.1.sh 2> null
Hello, world
[daa031@192 2]$ bash 2.1.sh 2> null
Hello, world
[daa031@192 2]$ bash 2.1.sh > null
Количество предыдущих запусков: 13
[daa031@192 2]$ cat null | less
[daa031@192 2]$ cat *.log | less
[daa031@192 2]$ cat 2.1.sh 
#!/bin/bash

log_file="run.log"
prev_runs=$(wc -l < "$log_file")
date >> "$log_file"
echo "Hello, world"
echo "Количество предыдущих запусков: $prev_runs" >&2


2.2. Разработать сценарий, который запускает сценарий, разработанный в предыдущем задании, а также открывает журнал запусков предыдущего сценария в программе less.
#!/bin/bash

./2.1.sh

less run.log




2.3. Разработать сценарий, который для bash.txt (созданного ранее):

сохранит строки, которые содержат сочетание символов 000000 в файл /tmp/zeros;
сохранит строки, которые не содержат сочетания символов 000000 - в файл /tmp/nozeros;
выведет 10 первых и 10 последних строк от каждого из файлов /tmp/zeros и /tmp/nozeros.


#!/bin/bash

input_file="bash.txt"

zeros_file="zeros"
nozeros_file="nozeros"

grep "000000" "$input_file" > "$zeros_file"

grep -v "000000" "$input_file" > "$nozeros_file"

echo "Первые 10 строк из $zeros_file:"
head -n 10 "$zeros_file"
echo "Последние 10 строк из $zeros_file:"
tail -n 10 "$zeros_file"

echo "Первые 10 строк из $nozeros_file:"
head -n 10 "$nozeros_file"
echo "Последние 10 строк из $nozeros_file:"
tail -n 10 "$nozeros_file"





2.4. Разработать сценарий, который считывает построчно стандартный ввод и выводит только те строки, которые содержат слово bin целиком в стандартный вывод ошибок. Для проверки сценария используйте конвейер с командой 'ls /.

#!/bin/bash


while read -r line; do

  if [[ "$line" == *'bin'* ]]; then

    echo "$line" >&2
  fi
done






2.5. Разработать сценарий, который для всех файлов с расширением txt в домашнем каталоге пользователя:

выведет список таких файлов;
выведет суммарный размер в байтах и строках для файлов с расширением txt.
Подсказка. Для решении этой задачи создайте временный файл в каталоге /tmp, по окончании работы сценария удалите его.

#!/bin/bash

# Путь к домашнему каталогу пользователя
home_directory="$HOME"

# Создаем временный файл для хранения списка файлов
temp_file=$(mktemp /tmp/txt_files.XXXXXX)

# Используем find для поиска файлов с расширением ".txt" в домашнем каталоге
find "$home_directory" -type f -name "*.txt" > "$temp_file"

# Выводим список найденных файлов
echo "Список файлов с расширением .txt:"
cat "$temp_file"

# Используем wc для подсчета строк в найденных файлах
total_lines=$(cat "$temp_file" | xargs wc -l | awk '{total += $1} END {print total}')

# Используем du для подсчета суммарного размера в байтах
total_size=$(cat "$temp_file" | xargs du -cb | tail -n 1 | cut -f1)

# Выводим суммарный размер и количество строк
echo "Суммарный размер файлов (в байтах): $total_size"
echo "Суммарное количество строк: $total_lines"

# Удаляем временный файл
rm "$temp_file"












2.6. Разработать сценарий поиска дубликатов файлов (файлы, с одинаковым содержимым), который выводит сначала количество дубликатов, затем имя файла. Файлы без дубликатов выводиться не должны.

Для подготовки выполните команды:

mkdir dups
cd dups
touch {1..3}.txt
echo 4 > 4.txt
echo 4 > 5.txt
echo 6 > 6.txt
Подсказка. Наиболее эффективным методом поиска дубликатов является вычисление их хэш-суммы с последующей их обработкой. У файлов-дубликатов хэш-суммы будут одинаковыми. Используйте команды sort, uniq, grep, tr, cut. Изучите как команды sort и uniq работают с колонками.

md5sum *.txt | ???? -k? | ???? -? -? ?? | ... | ... | ...
Должен получиться вывод:

2	4.txt
3	1.txt


Для поиска дубликатов файлов по их хэш-суммам и вывода количества дубликатов с их именами, вы можете воспользоваться следующим скриптом:

bash
Copy code
#!/bin/bash

# Путь к каталогу, где находятся файлы
directory="dups"

# Вычисляем хэш-суммы для файлов в каталоге и сортируем результат
md5sum "$directory"/*.txt | sort > md5sums.txt

# Используем команды sort, uniq и awk для подсчета дубликатов и вывода их имен
cat md5sums.txt | cut -f1 -d' ' | uniq -d | while read -r hash; do
  count=$(grep -c "$hash" md5sums.txt)
  if [ "$count" -gt 1 ]; then
    grep "$hash" md5sums.txt | head -n "$count" | cut -f2 -d' ' | tr '\n' '\t'
    echo "$count"
  fi
done

# Удаляем временный файл
rm md5sums.txt
Сохраните этот скрипт, например, как find_duplicates.sh, и дайте ему права на выполнение с помощью chmod +x find_duplicates.sh. Затем запустите его:

bash
Copy code
./find_duplicates.sh
Скрипт выполнит следующие действия:

Вычисляет хэш-суммы для файлов в указанном каталоге (dups) и сортирует их в файл md5sums.txt.

Использует команды cut, uniq и awk для подсчета дубликатов хэш-сумм и вывода их имен, а также количества дубликатов.

Удаляет временный файл md5sums.txt.



















===============================3. Аргументы командной строки и переменные==================================


