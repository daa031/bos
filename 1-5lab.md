# Лабораторная работа "Управление процессами. Capabilities"

Команды, изучаемые в лабораторной работе: `ps`, `top`, `pgrep`, `pstree`, `w`, `uptime`, `jobs`, `fg`, `bg`, `kill`, `killall`, `pkill`, `trap`, `getcap`, `setcap`.

# Тема: ПРОЦЕССЫ


## Команда `ps` {process status}

### Флаги:
---



- `-e` - {everyone} отображает информацию о всех процессах на системе, включая процессы всех пользователей.
```bash
    PID TTY          TIME CMD
      1 ?        00:00:01 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
```
`PID` - {Process ID} (идентификатор процесса)- уникальный числовой идентификатор процесса.

`TTY` - указывает на терминал (tty), к которому привязан процесс. ("?" - процесс не связан с каким-либо терминалом)

`TIME` - Этот столбец показывает общее количество центрального процессорного времени, затраченного процессом с момента его запуска. Время, в течение которого процесс использовал процессор.

`CMD` - команда или имя исполняемого файла, который был запущен как процесс. процесс systemd, который является первым процессом, запускаемым при загрузке системы.

---
--- 

- `-l` - {long} подробный вывод (PID (идентификатор процесса), PPID (идентификатор родительского процесса), статус процесса, UID, CPU использование).

```bash
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     830     806  0  80   0 -  3193 do_wai pts/0    00:00:00 su
4 S     0     834     830  0  80   0 -  1261 do_wai pts/0    00:00:00 bash
4 R     0    1408     834  0  80   0 -  1890 -      pts/0    00:00:00 ps
```
`F` - флаги состояния процесса 

`S` - статус процесса (`R`-Running; `S`-Sleeping; `D`-Disk sleep (в ожидании диска); `T`-Stopped(приостановлен); `Z` - Zombie (зомби): Этот флаг указывает на то, что процесс завершил свою работу, но его запись в системной таблице процессов еще не была удалена. Зомби-процессы обычно ожидают, чтобы их родительский процесс прочитал код завершения и завершил их запись. `I` - Idle (бездействие)

`UID` - идентификатор пользователя

`PPID` - идентификатор родительского процесса

`C` -  процент использования CPU, который занимает процесс.

`PRI` - содержит приоритет процесса.

`NI` -  значение "nice", которое влияет на приоритет процесса. Значение "0" означает нейтральный приоритет.

`ADDR` - указывает на адрес памяти процесса

`SZ` -  представляет размер процесса в килобайтах.

`WCHAN` - указывает на "wait channel", то есть на то, что процесс ожидает в данный момент.


--- 
--- 


- `-y` - {TTY} включает в выводе информацию о столбце "TTY" (терминал), который указывает, к какому терминалу привязан процесс. Если процесс не связан с каким-либо терминалом, поле будет пустым.

Столбец "RSS" в выводе команды ps -ly обозначает "Resident Set Size" (размер активной части памяти), и представляет собой объем физической оперативной памяти (RAM), который использует данный процесс в данный момент. Этот столбец показывает, сколько памяти занимает процесс, чтобы выполнять свои задачи.

---
---

- `-f` - {full} предоставляет полное описание процесса, включая информацию о командной строке запуска процесса, а также полный список атрибутов процесса.

- `-F` - {Full-format} предоставляет еще больше информации о процессах, включая дополнительные атрибуты, такие как UID, GID, время запуска и другие.



### Cинтаксис BSD
```bash
  $ ps ax
  $ ps axu
```
Используются для вывода информации о всех процессах в системе, включая процессы, не связанные с терминалом (`a`), и процессы для всех пользователей (`x`). То есть, комбинация ps ax используется для вывода списка процессов на системе без фильтрации по терминалу или пользователю. опция `u` в синтаксисе BSD используется для вывода более подробной информации о процессах, включая информацию о пользователе, который запустил процесс, процент использования CPU и памяти, время запуска и другие атрибуты. 


### Информация обо всех процессах в системе в виде дерева:

Эти команды выведут информацию о процессах в виде дерева, показывая связи между процессами и их родителями:
```bash
  $ ps -ejH
```
- `e` - все процессы, включая процессы других пользователей.
- `j` - дополнительную информацию о процессах, включая PPID (родительский процесс) и PGID (группа процессов).
- `H` - в виде дерева процессов, показывая связи между процессами и их родителями.


```bash
  $ ps axjf
```
- `a` - все процессы (аналогично опции -e в синтаксисе BSD).
- `x` - процессы, не связанные с терминалом .
- `f` - информацию о процессах в виде дерева процессов.


### Информация о легковесных процессах:
```bash
  $ ps -eLf
  $ ps axms
```
- `-e` - все процессы, включая процессы других пользователей.
- `-L` - отображает информацию о легковесных процессах (потоках) внутри каждого процесса. Легковесные процессы (потоки) могут быть частью многозадачных процессов.
Эта команда покажет информацию о легковесных процессах, включая их идентификаторы, приоритеты, состояния и другие атрибуты в контексте каждого родительского процесса.
- `f` - информации о процессах в виде дерева процессов.


- `a` - все процессы (аналогично опции -e в синтаксисе BSD).
- `x` - процессы, не связанные с терминалом (аналогично опции -x в синтаксисе BSD).
- `m` - информацию о легковесных процессах (потоках) внутри каждого процесса.
- `s` - представляет состояние (state) каждого легковесного процесса. 

### Атрибуты безопасности процессов

`ps -eo euser,ruser,suser,fuser,f,comm,label` - используются для вывода информации о процессах с различными атрибутами, такими как пользователь, реальный пользователь, запускающий пользователь, список файлов, флаги состояния процесса, имя команды и метка безопасности. 

- `-eo`: Эта опция указывает формат вывода для ps. В данном случае, `-e` означает, что будут выводиться все процессы, и `-o` означает, что мы определяем пользовательский формат вывода.

- `euser`: пользователь от имени которого выполняется процесс.

- `ruser`: пользователь, который запустил процесс.

- `suser`: пользователь, от имени которого был установлен субъект безопасности процесса.

- `fuser`: пользователь, от имени которого выполняется процесс файловой блокировки.

- `f`: Этот атрибут предоставляет информацию о флагах состояния процесса.

- `comm`: имя команды (программы), которая выполняется процессом.

- `label`: информация о метке безопасности процесса.
  

```bash
 $ ps axZ
```

```bash
  $ ps -eM
```



### Информация о процессах, выполняющихся от имени пользователя root (real & effective ID), в пользовательском формате:

```bash
  $ ps -U root -u root u
```

- `-U root`: Это опция, которая фильтрует процессы только для указанного пользователя "root". 
- `u` - формат вывода информации о процессах

### Информация о процессах в пользовательском формате:

```bash
  $ ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm
 ```

- `tid` - выводит идентификатор потока (TID)
- `class` - класс планировщика процесса.
- `rtprio` -  приоритет в реальном времени (если применимо).
- `ni` -  приоритет процесса (приоритет "nice").
- `pri` -  общий приоритет процесса.
- `psr`- номер процессора, на котором процесс выполняется.
- `pcpu` -  процент использования центрального процессора (CPU) процессом.
- `stat` -  остояние процесса (например, "R" для выполнения, "S" для ожидания и так далее).
- `wchan` -   информацию о точке ожидания, где процесс ожидает (до 14 символов).
- `comm` -  имя команды (программы), которую выполняет процесс.

---
---

```bash
 $ ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm
 ```

- `ax`: Опция -`a` означает, что будут отображены все процессы, и -`x` означает, что будут включены процессы, не связанные с терминалом.
- `euid`: эффективный идентификатор пользователя (effective user ID) процесса.
- `ruid`: реальный идентификатор пользователя (real user ID) процесса.
- `sess`:  идентификатор сессии процесса.



---
---

```bash
 $ ps -Ao pid,tt,user,fname,tmout,f,wchan
```

- `-A`: будут отображены все процессы на системе.
- `tt`:информацию о терминале, к которому привязан процесс.
- `user`: имя пользователя, от имени которого выполняется процесс.
- `fname`: выводит имя исполняемой команды (программы), которую выполняет процесс.
- `tmout`: нформацию о таймауте процесса (если применимо).
- `f`: от атрибут выводит флаги состояния процесса.
- `wchan`: выводит информацию о точке ожидания, где процесс ожидает.


### Только идентификаторы процессов с именем systemd:
```bash
 $ ps -C systemd -o pid=
```


### только имя процесса с идентификатором номер:
```bash
 $ ps -q номер -o comm=
```

## Выполнение процесса в основном и фоновом режимах

Если в одном терминале запустить бесконечный процесс (пишущий с интервалом в одну секунду строку ААА в файл test.out в домашнем каталоге)
```bash
 $ ( while true; do printf "AAA %d " $$ >> ~/test.out; sleep 1; done )
```
то в другом терминале можно будет отслеживать работу процесса при помощи
```bash
 $ tail -f ~/test.out
```

Чтобы запустить в фоновом режиме используется команда `bg` (background), а для продолжения выполнения приостановленного процесса - команда `fg` (foreground)

Остановить выполнение можно сочетанием клавиш `Ctrl+z`

При помощи команды `jobs` можно определить состояние процесса(BASH возвращает в квадратных скобках номер задания, а знаком плюс помечает текущее задание):
```bash
[daa@localhost 5lab]$ jobs
[1]+  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[daa@localhost 5lab]$ ps j
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
    805     806     806     806 pts/0       2040 Ss    1000   0:00 -bash
   1506    1507    1507    1507 pts/1       2147 Ss    1000   0:00 -bash
   1507    2036    2036    1507 pts/1       2147 T     1000   0:00 -bash
   2036    2138    2036    1507 pts/1       2147 T     1000   0:00 sleep 1
   1507    2147    2147    1507 pts/1       2147 R+    1000   0:00 ps j
[daa@localhost 5lab]$ bg
[1]+ ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done ) &
[daa@localhost 5lab]$ jobs
[1]+  Running                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done ) &
[daa@localhost 5lab]$ ps j
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
    805     806     806     806 pts/0       2040 Ss    1000   0:00 -bash
   1506    1507    1507    1507 pts/1       2183 Ss    1000   0:00 -bash
   1507    2036    2036    1507 pts/1       2183 S     1000   0:00 -bash
   2036    2182    2036    1507 pts/1       2183 S     1000   0:00 sleep 1
   1507    2183    2183    1507 pts/1       2183 R+    1000   0:00 ps j

```
Если в первом терминале запустить второй бесконечный процесс (с функционалом аналогичным первому) при помощи команды
```bash
[daa@localhost 5lab]$  ( while true; do printf "UUU %d " $$ >> test.out; sleep 1; done ) &
[2] 2467
```
То в состояниях процесса мы увидим следующее:
```bash
[daa@localhost 5lab]$ jobs
[1]-  Running                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done ) &
[2]+  Running                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done ) &

```
Далее после завершения процессов при помощи команды `fg %номер задания`, то в состояниях процессов мы увидим следующее: 
```bash
[daa@localhost 5lab]$ fg 1
( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
^C
[daa@localhost 5lab]$ jobs
[2]+  Stopped                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
[daa@localhost 5lab]$ fg 2
( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
^C
[daa@localhost 5lab]$ jobs
[daa@localhost 5lab]$ 
```

## Посылка сигналов процессам

1. 

2. 
```bash
[root@localhost 5lab]# ( while true; do printf "AAA %d " $$ >> test.out; sleep 1; done ) &
[1] 2931
[root@localhost 5lab]# ( while true; do printf "UUU %d " $$ >> test.out; sleep 1; done ) &
[2] 2940
[root@localhost 5lab]# jobs 
[1]-  Running                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done ) &
[2]+  Running                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done ) &
[root@localhost 5lab]# ps j
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
      1     710     710     710 tty1         710 Ss+      0   0:00 /sbin/agetty -o -p -- \u --noclear - linux
    806     830     830     806 pts/0       2967 S        0   0:00 su -
    830     834     834     806 pts/0       2967 S        0   0:00 -bash
    834    2931    2931     806 pts/0       2967 S        0   0:00 -bash
    834    2940    2940     806 pts/0       2967 S        0   0:00 -bash
   2931    2965    2931     806 pts/0       2967 S        0   0:00 sleep 1
   2940    2966    2940     806 pts/0       2967 S        0   0:00 sleep 1
    834    2967    2967     806 pts/0       2967 R+       0   0:00 ps j

```
3. 
```bash
tail -f test.out
```
4. 
```bash
[root@localhost 5lab]# kill -SIGSTOP %1

[1]+  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[root@localhost 5lab]# jobs 
[1]+  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[2]-  Running                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done ) &

```
5. 
```bash
[root@localhost 5lab]# kill -SIGSTOP %2

[2]+  Stopped                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
[root@localhost 5lab]# jobs
[1]-  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[2]+  Stopped                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
```
6. 
```bash
[root@localhost 5lab]$ fg
( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
^C
[root@localhost 5lab]$ jobs
[1]+  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[root@localhost 5lab]$ fg
( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
^C
[root@localhost 5lab]$ jobs
[root@localhost 5lab]$ 
```

## Изучение команд trap и sleep 

`trap` - озволяет установить обработчик на сигнал. Опция `-l` выводит список сигналов. Опция `-p` выводит установленные обработчики сигналов.

```bash
  $ trap -l
   1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
   6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
  11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
  16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
  21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
  26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
  31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
  38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
  43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
  48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
  53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
  58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
  63) SIGRTMAX-1	64) SIGRTMAX
  
  ```
Запустите дочерний shell и установите обработчик сигнала EXIT (0, который посылается нажатием Ctrl+d).

  ```bash
    $ sh
  sh-4.3$ trap 'echo Завершение работы...; sleep 2' EXIT
  sh-4.3$ trap -p EXIT
  trap -- 'echo Завершение работы...; sleep 2' EXIT
  ```

  Создайте сценарий.
  ```bash
    #!/bin/bash
  declare -i i=0
  trap 'echo "Аварийное завершение..."; exit 1' SIGINT
  while [ $i -lt 100 ]
  do
  	(( i++ ))
  	echo $i
  	sleep 1
  done
  ```
Запустите сценарий.

```bash
  $ chmod +x test-trap.sh
  $ ./test-trap.sh
```
Завершите сценарий. Объясните результаты.

```bash
[root@localhost 5lab]# ./test-trap.sh 
1
2
^CАварийное завершение...
[root@localhost 5lab]# 

```

`trap 'echo "Аварийное завершение..."; exit 1' SIGINT`: Эта строка устанавливает обработчик события SIGINT. При получении сигнала прерывания (Ctrl+C), будет выполнена команда echo "Аварийное завершение...", а затем скрипт завершится с кодом возврата 1.


## Изучение возможностей файловых систем procfs и sysfs


1. Изучите содержимое файла `/proc/version` и сравните с выводом команды `uname -a`.

```bash
[root@localhost ~]$ cat /proc/version 
Linux version 5.14.0-284.11.1.el9_2.x86_64 (mockbuild@iad1-prod-build001.bld.equ.rockylinux.org) (gcc (GCC) 11.3.1 20221121 (Red Hat 11.3.1-4), GNU ld version 2.35.2-37.el9) #1 SMP PREEMPT_DYNAMIC Tue May 9 17:09:15 UTC 2023
```

```bash
[root@localhost ~]$ uname -a
Linux localhost.localdomain 5.14.0-284.11.1.el9_2.x86_64 #1 SMP PREEMPT_DYNAMIC Tue May 9 17:09:15 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux
[root@localhost ~]# 
```

2. Изучите и сравните содержимое файлов `/proc/meminfo` и `/sys/devices/system/node/node0/meminfo`, и вывод команды `free`.


- `/proc/meminfo`: 
```bash 
      [alex@fedora ~]$ cat /proc/meminfo 
      MemTotal:        8035788 kB
      MemFree:         2668476 kB
      MemAvailable:    5903612 kB
```
- `/sys/devices/system/node/`: 
```bash
      [alex@fedora ~]$ cat /sys/devices/system/node/node0/meminfo
      Node 0 MemTotal:        8035788 kB
      Node 0 MemFree:         2638064 kB
      Node 0 MemUsed:         5397724 kB
```
- `free`
```bash
               total        used        free      shared  buff/cache   available
Mem:         8035788     1473528     2622088      433632     3940172     5857488
Swap:        8035324           0     8035324
```

3. Изучите содержимое файла /proc/cpuinfo. Определите количество ядер.

```bash
cpu cores: 1 указывает на количество физических ядер.
siblings: 1 указывает на количество потоков (гиперпотоков).
```

  (данные будут меняться, если предоставить больше ядер виртуальной машине)

4. Изучите содержимое файла /proc/uptime и сравните с выводом команды uptime. 

```bash
[daa@localhost ~]$ cat /proc/uptime
96.12 179.89
[daa@localhost ~]$ uptime
 01:20:49 up 1 min,  1 user,  load average: 0.05, 0.03, 0.01
[daa@localhost ~]$ 
```
(1)время с момента последней загрузки системы. 
(2) Это время отражает периоды, когда система была неактивной, и процессоры были в состоянии простоя.

01:20:49: Текущее время.
up 1 min: Время работы системы: 3 дня, 2 часа и 25 минут.
1 user: Количество активных пользователей в данный момент.
load average: 0.05, 0.03, 0.01: Средняя загрузка за последние 1, 5 и 15 минут соответственно.


5. Изучите специальную символьную ссылку /proc/self, которая указывает на подкаталог текущего процесса. В переменной $ хранится PID текущего процесса. Объясните результаты.

```bash
[daa@localhost ~]$ echo $$
817
[daa@localhost ~]$ ls -l /proc/self
lrwxrwxrwx. 1 root root 0 Nov 10 01:20 /proc/self -> 1377
[daa@localhost ~]$ ls -l /proc/$$
dr-xr-xr-x. 9 daa daa 0 Nov 10 01:20 /proc/817
[daa@localhost ~]$ 
```
- `$$` - это встроенная переменная, представляющая идентификатор текущего исполняемого процесса. 

`$$` - pid shell

`/self/` - pid ls



"$$" это специальная переменная bash, которая расширяется до pid оболочки.

/proc/self является ли реальный символическая ссылка на /proc/ подкаталог процесса, который выполняет вызов.

Когда вы делаете ls /proc/$$ оболочка расширяет его до ls /proc/pid-of-bash и это то, что вы видите, содержимое процесса оболочки.

Но когда вы это делаете ls /proc/self вы видите содержимое недолговечного ls процесса.



- `/proc/self`- является специальной символической ссылкой, которая всегда указывает на каталог /proc/PID/, где PID - это идентификатор текущего процесса (Process ID) в момент выполнения команды. Иными словами, /proc/self - это символическая ссылка, которая динамически заменяется на каталог, соответствующий PID процесса, выполняющего команду.

- `ls -ld /proc/$$` - Показывает атрибуты каталога /proc/3203, где 3203 - это PID текущего процесса. Этот каталог представляет собой директорию с информацией о текущем процессе, такой как файлы cmdline, status, maps, и другие. 


6. Изучите содержимое файла /proc/PID_процесса/stat. Формат вывода можно посмотреть в исходном коде ядра Linux в файле /fs/proc/array.c в функции do_task_stat().

```bash
  read pid tcomm state other < /proc/$$/stat
  echo "Процесс $pid $tcomm находится в состоянии $state"
  Процесс 3203 (bash) находится в состоянии R
```

## Работа процесса с файлами

1. Изучите различные формы обращения к файловым дескрипторам и потокам stdin, stdout, stderr.
```bash
[daa@localhost ~]$ ls -l /dev/std*
lrwxrwxrwx. 1 root root 15 Nov 10 01:20 /dev/stderr -> /proc/self/fd/2
lrwxrwxrwx. 1 root root 15 Nov 10 01:20 /dev/stdin -> /proc/self/fd/0
lrwxrwxrwx. 1 root root 15 Nov 10 01:20 /dev/stdout -> /proc/self/fd/1
[daa@localhost ~]$ ls -l /dev/fd/
total 0
lrwx------. 1 daa daa 64 Nov 10 02:40 0 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 02:40 1 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 02:40 2 -> /dev/pts/0
lr-x------. 1 daa daa 64 Nov 10 02:40 3 -> /proc/1467/fd
```
- `/dev/stderr` - это символическая ссылка на файловый дескриптор, используемый для записи сообщений об ошибках.
- `/proc/self` - Это специальная символическая ссылка в Linux, которая всегда указывает на текущий процесс. В данном случае, /proc/self указывает на информацию о текущем процессе.
- `/fd/2` - В Linux, /proc/self/fd/ содержит символические ссылки на открытые файловые дескрипторы текущего процесса, и каждая такая ссылка представляет собой файловый дескриптор.

Таким образом, /dev/stderr фактически указывает на файловый дескриптор 2 текущего процесса, который представляет собой стандартный вывод ошибок. При записи в /dev/stderr, данные фактически попадают в файловый дескриптор 2 и выводятся в стандартный вывод ошибок процесса.

- `/dev/pts/0`: Это устройство псевдотерминала с индексом 0. Когда пользователь входит в систему в текстовом режиме или открывает терминал в графическом интерфейсе, система создает псевдотерминал и связывает его с терминалом пользователя. /dev/pts/0 будет использоваться для ввода и вывода этого терминала.Когда вы видите, что файловые дескрипторы (0, 1, 2) направлены в /dev/pts/0, это означает, что стандартный ввод, вывод и вывод ошибок направлены на терминал, связанный с этим псевдотерминалом. В этом терминале пользователь может взаимодействовать с командной оболочкой и другими программами, используя текстовый интерфейс.

-  `/proc/1467/fd`: Эта строка описывает символическую ссылку 3, указывающую на файловый дескриптор 3. Однако, в отличие от предыдущих строк, она не указывает на терминал. Вместо этого, файловый дескриптор 3 направлен на каталог файловых дескрипторов процесса с PID 1467, который скорее всего представляет собой другой процесс в системе.


2. Изучите список открытых файлов процесса. Определите потоки stdin, stdout, stderr.
```bash
[daa@localhost ~]$ ls -l /proc/self/fd
total 0
lrwx------. 1 daa daa 64 Nov 10 03:06 0 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 03:06 1 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 03:06 2 -> /dev/pts/0
lr-x------. 1 daa daa 64 Nov 10 03:06 3 -> /proc/1684/fd
```

Таким образом, ls -l /dev/fd/ предоставляет более общую информацию о файловых дескрипторах в системе, в то время как ls -l /proc/self/fd фокусируется на файловых дескрипторах текущего процесса.

3. Перенаправьте потоки stdout и stderr в файлы. Объясните результаты.
```bash
[root@localhost 4lab]# ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err
[root@localhost 4lab]# cat /tmp/ls.out 
total 0
lrwx------. 1 root root 64 Nov 10 03:24 0 -> /dev/pts/0
l-wx------. 1 root root 64 Nov 10 03:24 1 -> /tmp/ls.out
l-wx------. 1 root root 64 Nov 10 03:24 2 -> /tmp/ls.err
lr-x------. 1 root root 64 Nov 10 03:24 3 -> /proc/2633/fd
[root@localhost 4lab]# 
```

4. Перенаправьте поток stdin. Объясните права доступа.

```bash
[root@localhost 4lab]# ls -l /proc/self/fd < /root/4lab/new > /tmp/ls.in
[root@localhost 4lab]# cat /tmp/ls.in 
total 0
lr-x------. 1 root root 64 Nov 10 03:32 0 -> /root/4lab/new
l-wx------. 1 root root 64 Nov 10 03:32 1 -> /tmp/ls.in
lrwx------. 1 root root 64 Nov 10 03:32 2 -> /dev/pts/0
lr-x------. 1 root root 64 Nov 10 03:32 3 -> /proc/3144/fd
```

# Исследование взаимодействия параллельных процессов через каналы

1. В левом окне запустите конвейер, перенаправьте потоки stdout и stderr в файлы в домашнем каталоге.
```bash
( cat | head ) > ~/test.out 2> ~/test.err
```
2. В правом окне выведите списки открытых файлов процессов bash, cat и head.

```bash
[daa@192 ~]$ ps j
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
   4220    4221    4221    4221 pts/0       4359 Ss    1000   0:00 -bash
   4272    4273    4273    4273 pts/1       4366 Ss    1000   0:00 -bash
   4221    4359    4359    4221 pts/0       4359 S+    1000   0:00 -bash
   4359    4360    4359    4221 pts/0       4359 S+    1000   0:00 cat
   4359    4361    4359    4221 pts/0       4359 S+    1000   0:00 head
   4273    4366    4366    4273 pts/1       4366 R+    1000   0:00 ps j
[daa@192 ~]$  ls -l /proc/4359/fd
total 0
lrwx------. 1 daa daa 64 Nov 10 03:59 0 -> /dev/pts/0
l-wx------. 1 daa daa 64 Nov 10 03:59 1 -> /home/daa/test.out
l-wx------. 1 daa daa 64 Nov 10 03:59 2 -> /home/daa/test.err
lrwx------. 1 daa daa 64 Nov 10 03:59 255 -> /dev/pts/0
[daa@192 ~]$  ls -l /proc/4360/fd
total 0
lrwx------. 1 daa daa 64 Nov 10 04:00 0 -> /dev/pts/0
l-wx------. 1 daa daa 64 Nov 10 04:00 1 -> 'pipe:[25143]'
l-wx------. 1 daa daa 64 Nov 10 04:00 2 -> /home/daa/test.err
[daa@192 ~]$  ls -l /proc/4361/fd
total 0
lr-x------. 1 daa daa 64 Nov 10 04:00 0 -> 'pipe:[25143]'
l-wx------. 1 daa daa 64 Nov 10 04:00 1 -> /home/daa/test.out
l-wx------. 1 daa daa 64 Nov 10 04:00 2 -> /home/daa/test.err
```
3. Изучите как поток stdout процесса cat связан с потоком stdin процесса head.

Процесс cat (PID 4359):

0 -> /dev/pts/0: stdin процесса cat связан с терминалом (/dev/pts/0).
1 -> /home/daa/test.out: stdout процесса cat связан с файлом /home/daa/test.out.
2 -> /home/daa/test.err: stderr процесса cat связан с файлом /home/daa/test.err.

Процесс head (PID 4361):

0 -> 'pipe:[25143]': stdin процесса head связан с каналом, обозначенным как 'pipe:[25143]'.
1 -> /home/daa/test.out: stdout процесса head связан с файлом /home/daa/test.out.
2 -> /home/daa/test.err: stderr процесса head связан с файлом /home/daa/test.err.
Таким образом, процесс cat выводит данные в канал, а процесс head читает данные из этого канала в качестве входных данных (stdin). Это обеспечивает передачу вывода процесса cat в процесс head.

Канал (pipe) - это механизм в Unix-подобных операционных системах, который позволяет связывать вывод одного процесса с вводом другого. Это создает "канал" для передачи данных между процессами.

Когда создается канал, операционная система устанавливает два файловых дескриптора: один для чтения (stdin) и один для записи (stdout). Данные, записанные в вывод (stdout) одного процесса, могут быть прочитаны из ввода (stdin) другого процесса.


4. В левом окне завершите процессы.

5. В левом окне создайте именованный канал и запустите команду cat с перенаправлением вывода в созданный канал.

```bash
 mkfifo ~/fifo1
 cat > ~/fifo1
```

mkfifo ~/fifo1: Создает именованный канал с именем fifo1 в домашнем каталоге (~/). После выполнения этой команды, появится специальный файл fifo1, который можно использовать для передачи данных между процессами.

cat > ~/fifo1: Запускает команду cat для чтения данных из стандартного ввода и записи их в именованный канал fifo1. В этом случае, вы можете вводить текст с клавиатуры, и этот текст будет записываться в канал fifo1.
6. 
```bash
cat < ~/fifo1
```

7. Откройте новое окно терминала, в котором выведите списки открытых файлов двух процессов cat.

8. В новом (третьем) окне запустите команду cat с перенаправлением ввода из канала.
```bash
cat < ~/fifo1
```
9. В левом окне вводите строки текста и наблюдайте вывод в двух других окнах. Объясните результаты.

- есть три окна  в 1 `cat > ~/fifo1` во 2  и 3 `cat < ~/fifo1`
в результатет когда вводим строки в 1 окно они чередуются в 2 и 3 (1стр в 2; 2 в 3; 3  в 2 и тд )
- Команды cat в терминалах 2 и 3 начинают читать данные из fifo1. Однако они читают данные поочередно. 

10.  Организуйте чтение из канала в бесконечном цикле while с помощью команды read.

```bash
while true; do read str < ~/fifo1; echo "received: $str"; done
```

## Изучение команды exec 


Команда exec в Unix-подобных операционных системах выполняет указанную программу, заменяя текущий процесс новым. Она обычно используется для перезапуска команды в текущем процессе или для запуска новой программы с заменой текущего процесса

1. Запустите дочерний shell и заместите коды порожденного процесса кодами команды ps -l. Обратите внимание на то, что PID процесса sh совпадает с PID процесса ps (5510). Объясните результаты.

```bash
[daa@192 ~]$ sh
sh-5.1$ ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000    4221    4220  0  80   0 -  1229 do_wai pts/0    00:00:00 bash
0 S  1000    5510    4221  0  80   0 -  1229 do_wai pts/0    00:00:00 sh
0 R  1000    5513    5510  0  80   0 -  1890 -      pts/0    00:00:00 ps
sh-5.1$ exec ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000    4221    4220  0  80   0 -  1229 do_wai pts/0    00:00:00 bash
0 R  1000    5510    4221  0  80   0 -  1890 -      pts/0    00:00:00 ps
[daa@192 ~]$ ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000    4221    4220  0  80   0 -  1229 do_wai pts/0    00:00:00 bash
0 R  1000    5514    4221  0  80   0 -  1890 -      pts/0    00:00:00 ps
[daa@192 ~]$ 

```

exec ps -l: Эта команда использует exec для замены текущего процесса (который является вашей командной оболочкой sh в данном случае) на новый процесс ps -l. Поэтому после выполнения этой команды, ваш терминал будет связан с процессом ps -l, и он заменяет оболочку.


Когда вы вводите команду exec ps -l, она использует exec для замены текущего процесса sh новым процессом ps -l. При этом PID (идентификатор процесса) остается тем же. Таким образом, PID процесса ps -l совпадает с PID процесса sh, который был заменен.

Это обычное поведение при использовании exec, так как exec заменяет текущий процесс новым, сохраняя тот же идентификатор процесса.

2. Исследуйте работу процесса с файлами на примере bash. Откройте файл ~/test.out на запись и свяжите его с дескриптором 3.

```bash
[daa@192 ~]$ exec 3> ~/test.out 
[daa@192 ~]$ ls -l /proc/$$/fd
total 0
lrwx------. 1 daa daa 64 Nov 10 07:27 0 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 07:27 1 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 07:27 2 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 07:27 255 -> /dev/pts/0
l-wx------. 1 daa daa 64 Nov 10 07:27 3 -> /home/daa/test.out
[daa@192 ~]$ echo TESt
TESt
[daa@192 ~]$ echo TESt3 >&3
[daa@192 ~]$ cat ~/test.out 
TESt3
[daa@192 ~]$ echo TESt33333 >&3
[daa@192 ~]$ cat ~/test.out 
TESt3
TESt33333
[daa@192 ~]$ 
```

3. Выведите информацию об открытых файлах процесса bash. Объясните позицию указателя чтения/записи (pos: 14).

```bash
[daa@192 ~]$ echo $$
4221
[daa@192 ~]$ ls -l /proc/4221/fdinfo/
total 0
-r--r--r--. 1 daa daa 0 Nov 10 07:40 0
-r--r--r--. 1 daa daa 0 Nov 10 07:40 1
-r--r--r--. 1 daa daa 0 Nov 10 07:40 2
-r--r--r--. 1 daa daa 0 Nov 10 07:40 255
-r--r--r--. 1 daa daa 0 Nov 10 07:40 3
[daa@192 ~]$ cat /proc/4221/fdinfo/3
pos:	16
flags:	0100001
mnt_id:	63
ino:	50565869
[daa@192 ~]$ ls -l /proc/$$/fdinfo/
total 0
-r--r--r--. 1 daa daa 0 Nov 10 07:40 0
-r--r--r--. 1 daa daa 0 Nov 10 07:40 1
-r--r--r--. 1 daa daa 0 Nov 10 07:40 2
-r--r--r--. 1 daa daa 0 Nov 10 07:40 255
-r--r--r--. 1 daa daa 0 Nov 10 07:40 3
[daa@192 ~]$ cat /proc/$$/fdinfo/3
pos:	16
flags:	0100001
mnt_id:	63
ino:	50565869
[daa@192 ~]$ 
```
Таким образом, pos: 16 говорит о том, что текущая позиция указателя чтения/записи в файле равна 14 байтам от начала файла. Это означает, что следующая операция записи будет производиться с 17-го байта файла

Из вывода не видно конкретного пути к файлу. Однако, по контексту, это вероятно файл, который был открыт файловым дескриптором 3 процесса с PID 3203. Команда exec 3> ~/test.out открывает файл для записи, и, вероятно, ~/test.out - это файл, который связан с этим файловым дескриптором. Таким образом, позиция указателя чтения/записи (pos: 14) относится к этому файлу (~/test.out).



4. Откройте файл ~/test.out на чтение и свяжите его с дескриптором 4.
```bash
[daa@192 ~]$ exec 4< ~/test.out
[daa@192 ~]$ ls -l /proc/$$/fd
total 0
lrwx------. 1 daa daa 64 Nov 10 07:27 0 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 07:27 1 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 07:27 2 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 07:27 255 -> /dev/pts/0
l-wx------. 1 daa daa 64 Nov 10 07:27 3 -> /home/daa/test.out
lr-x------. 1 daa daa 64 Nov 10 08:13 4 -> /home/daa/test.out
[daa@192 ~]$ cat ~/test.out
Test4
[daa@192 ~]$ cat <&4
Test4
[daa@192 ~]$ cat ~/test.out
Test4
[daa@192 ~]$ cat <&4
[daa@192 ~]$ 
[daa@192 ~]$ echo Test42 >&3
[daa@192 ~]$ cat ~/test.out
Test4
Test42
[daa@192 ~]$ cat <&4
Test42
[daa@192 ~]$ cat <&4
[daa@192 ~]$ 
```

- `exec 4< ~/test.out`: Эта команда открывает файл ~/test.out для чтения и связывает файловый дескриптор 4 с этим файлом.
- `ls -l /proc/$$/fd`: Эта команда выводит список открытых файловых дескрипторов для текущего процесса. Здесь видно, что файловый дескриптор 4 связан с файлом /home/daa/test.out.
- `cat ~/test.out`: Команда cat выводит содержимое файла ~/test.out.
- `cat <&4`: Команда cat читает из файлового дескриптора 4 (связанного с файлом ~/test.out), и результат выводится на экран.

-`echo Test42 >&3`: Эта команда пишет строку "Test42" в файловый дескриптор 3 (который предварительно был связан с файлом ~/test.out).

- `cat ~/test.out`: Выводит содержимое файла ~/test.out, включая добавленную строку "Test42".

- `cat <&4`: Команда cat читает из файлового дескриптора 4 (связанного с файлом ~/test.out), и результат выводится на экран. Заметьте, что после операции записи в файл, указатель чтения/записи в файле может быть смещен, и если его не сбросить, читаемая информация может быть неактуальной.

- `cat <&4`: Повторное выполнение команды cat для чтения из файлового дескриптора 4.

Это может быть связано с тем, что после операции записи в файл, указатель чтения/записи в файле смещается в конец файла. После завершения операции записи, указатель смещается в конец файла, и если вы попытаетесь снова прочитать файл, вы получите пустой вывод, так как нет новых данных после текущей позиции указателя.

5. Удалите файл ~/test.out.

```bash
[daa@192 ~]$ rm ~/test.out
[daa@192 ~]$ ls -l /proc/$$/fd
total 0
lrwx------. 1 daa daa 64 Nov 10 07:27 0 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 07:27 1 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 07:27 2 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 07:27 255 -> /dev/pts/0
l-wx------. 1 daa daa 64 Nov 10 07:27 3 -> '/home/daa/test.out (deleted)'
lr-x------. 1 daa daa 64 Nov 10 08:13 4 -> '/home/daa/test.out (deleted)'
[daa@192 ~]$ 
```
6. Попробуйте вывести содержимое файла ~/test.out командой cat, используя два способа обращения к файлу: через дескриптор и через имя. Объясните результат.

```bash
[daa@192 ~]$ cat <&4
[daa@192 ~]$ cat ~/test.out
cat: /home/daa/test.out: No such file or directory
[daa@192 ~]$ 
```
- `exec 4<&-  # Закроет файловый дескриптор 4`

## Разработка сценария
Найти в системе все процессы, у которых различаются реальные и эффективные пользовательские идентификаторы. Для обнаруженных процессов вывести имя программы.

Для тестирования можно использовать программу passwd.


```bash
ps -e -o pid,comm,ruid,euid | awk '$3 != $4 {print $1, $2, $3, $4}'
```

ps -e: Команда ps используется для отображения текущих процессов. Флаг -e указывает, что нужно выводить информацию обо всех процессах.

-o pid,comm,ruid,euid: Флаг -o позволяет настроить формат вывода. Здесь указаны поля, которые будут отображаться:

`pid`: Идентификатор процесса.
`comm`: Название команды (программы).
`ruid`: Реальный идентификатор пользователя (Real User ID).
`euid`: Эффективный идентификатор пользователя (Effective User ID).
| awk '$3 != $4 {print $1, $2, $3, $4}': Эта часть использует конвейер (|), чтобы передать вывод ps на вход команде awk. Здесь awk выполняет следующее:

$3 != $4: Условие, проверяющее, не совпадают ли реальный и эффективный идентификаторы пользователя.
{print $1, $2, $3, $4}: Если условие истинно, выводятся поля PID, команды, реального и эффективного UID.


## Контрольные вопросы по теме процессов

1. Что происходит при прерывании скрипта text-trap.sh? Объясните, почему.
```bash
  $ cat test-trap.sh
  #!/bin/bash
  declare -i i=0
  trap 'echo "Аварийное завершение..."; exit 1' SIGINT
  while [ $i -lt 100 ]
  do
  	(( i++ ))
  	echo $i
  	sleep 1
  done
```
Ответ: `trap 'echo "Аварийное завершение..."; exit 1' SIGINT`: Эта строка устанавливает обработчик события SIGINT. При получении сигнала прерывания (Ctrl+C), будет выполнена команда echo "Аварийное завершение...", а затем скрипт завершится с кодом возврата 1.

2. Напишите, по какой причине выводы команды ls -l /proc/self и ls -l /proc/$$ отличаются?

Ответ:
`$$` - pid shell

`/self/` - pid ls

$$ это специальная переменная bash, которая расширяется до pid оболочки.

/proc/self является ли реальный символическая ссылка на /proc/ подкаталог процесса, который выполняет вызов.

Когда вы делаете ls /proc/$$ оболочка расширяет его до ls /proc/pid-of-bash и это то, что вы видите, содержимое процесса оболочки.

Но когда вы это делаете ls /proc/self вы видите содержимое недолговечного ls процесса.

3. Напишите, какие дескрипторы в выводе команды ls -l /proc/self/fd отвечают за stdin, stdout, stderr.

Ответ:
```bash
lrwx------. 1 user user 64 Nov 10 03:10 0 -> /dev/pts/0  # stdin
lrwx------. 1 user user 64 Nov 10 03:10 1 -> /dev/pts/0  # stdout
lrwx------. 1 user user 64 Nov 10 03:10 2 -> /dev/pts/0  # stderr
```
/dev/pts/0 - это псевдотерминал 

4. Что происходит с дескрипторами при перенаправлении потоков stdout и stderr в файлы при выполнении команды ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err?

Ответ:

Когда вы выполняете команду ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err, происходит следующее:

ls -l /proc/self/fd: Эта команда выводит список дескрипторов файлов для текущего процесса (где /proc/self - это символическая ссылка на директорию, представляющую текущий процесс в /proc).

> /tmp/ls.out: Эта часть перенаправляет стандартный вывод (stdout) команды в файл /tmp/ls.out.

2> /tmp/ls.err: Эта часть перенаправляет поток ошибок (stderr) команды в файл /tmp/ls.err.

Таким образом, результаты команды ls -l /proc/self/fd записываются в файл /tmp/ls.out, а любые сообщения об ошибках записываются в файл /tmp/ls.err. Эти перенаправления не влияют на дескрипторы файлов в /proc/self/fd, они просто определяют, куда направляются вывод и ошибки при выполнении команды.

5. Запишите эту же команду, добавив к ней перенаправление потока stdin. Что изменилось?

Ответ:

Команда с перенаправлением потока stdin, stdout и stderr будет выглядеть так:


`ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err < file.txt `Здесь < file.txt перенаправляет поток stdin из файла file.txt (пустой файл, который возвращает конец файла сразу же при попытке чтения). В данном случае это может быть избыточным, так как команда ls вряд ли что-то считывает из stdin, но это может быть полезным в других сценариях для явного предотвращения чтения из stdin.

6. Какой эффект наблюдается при выполнении команды exec ps -l?

Ответ:

Когда вы выполняете команду exec ps -l, происходит замена текущего процесса (в данном случае, интерпретатора командной строки) процессом ps -l. Таким образом, интерпретатор командной строки больше не существует, и вместо него работает процесс ps -l.

Следует отметить, что при использовании exec текущий процесс полностью заменяется новым процессом, и после выполнения команды exec не возвращается к предыдущему состоянию

7. Что означает pos при выводе содержимого файла /proc/$$/fdinfo/3?

Ответ:

В контексте вывода содержимого файла /proc/$$/fdinfo/3, поле pos означает текущую позицию указателя чтения/записи в файле для соответствующего файлового дескриптора. Значение pos: 16 указывает, что указатель чтения/записи находится на 16 байтах от начала файла.

8. Существует ли возможность читать содержимое файла test.out даже после его удаления? Почему так происходит?

Ответ:

Да, это возможно. В Linux, когда процесс открывает файл, он связывается с индексным дескриптором файла (file descriptor). Даже если сам файл был удален из файловой системы (например, с помощью команды rm), процесс все еще может обращаться к файлу через открытый дескриптор.

Когда файл удаляется, его запись в файловой системе помечается как удаленная, но сам файл не удаляется из системы, пока существует хотя бы один открытый дескриптор. Когда последний дескриптор будет закрыт, система освободит ресурсы, связанные с файлом.

# Привилегии (capabilities)

## Привилегии процесса

Механизм привилегий (capabilities) позволяет разделить неограниченные права суперпользователя (у которого EUID == 0) по администрированию системы на отдельные группы прав, которые могут быть независимо друг от друга предоставлены обычным пользователям (у которых EUID != 0). Этим достигается реализация принципа наименьших привилегий, а также уменьшается поверхность атаки: если программа, обладающая одной или более привилегиями скомпрометирована, ее возможности по нанесению ущерба системе будут меньше по сравнению с такой же программой, выполняющейся с EUID == 0.

Каждый процесс обладает пятью 64-битными векторами привилегий. Эти векторы хранятся в структуре cred, на которую ссылается указатель из дескриптора процесса task_struct.

Рассмотрим фрагмент структуры cred:

```bash

struct cred {
    // ...
    kernel_cap_t cap_inheritable;
    kernel_cap_t cap_permitted;
    kernel_cap_t cap_effective;
    kernel_cap_t cap_bset;
    kernel_cap_t cap_ambient;
    // ...
}

```
- Наследуемый вектор (inheritable) — привилегии, которые сохраняются при выполнении вызова execve. Наследуемые привилегии остаются наследуемыми при выполнении любой программы. Наследуемые привилегии добавляются к разрешенному набору при выполнении программы, у которой есть соответствующие биты в наследуемом наборе файла.

- Разрешенный вектор (permitted) — максимальный набор привилегий, которые может использовать процесс (является надмножеством эффективного набора). Это также максимальный набор привилегий, которые могут быть добавлены в наследуемый набор процессом, не имеющим привилегию CAP_SETPCAP в своем эффективном наборе. Если процесс удаляет привилегию из своего разрешенного набора, он никогда не сможет повторно получить эту возможность. Исключения составляют случаи запуска в процессе программы с установленным битом SUID или программы с установленной привилегией на исполняемый файл.

- Эффективный вектор (effective) – набор привилегий, используемый ядром при выполнении проверок доступа для процесса (permission checks).


- Ограничивающий вектор (bounding) – механизм, который может использоваться для ограничения привилегий, получаемых во время вызова execve.

- Внешний вектор (ambient) – привилегии, которые сохраняются при выполнении вызова execve привилегированной программой. Привилегия может быть внешней, если она одновременно разрешенная и наследуемая. Внешние привилегии автоматически сбрасываются, если соответствующая разрешенная или наследуемая привилегия сбрасывается.

Посмотреть привилегии процесса можно в файле /proc/<pid>/status. Рассмотрим на примере обычного пользователя user1 привилегии процесса bash:

```bash
id
# Вывод:
# uid=1001(user1) gid=1001(user1) groups=1001(user1) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

cat /proc/self/status | grep ^Cap
# Вывод:
# CapInh: 0000000000000000
# CapPrm: 0000000000000000
# CapEff: 0000000000000000
# CapBnd: 000001ffffffffff
# CapAmb: 0000000000000000

capsh --print
# Вывод:
# Current: =
# Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,38,39,40
# Ambient set =
# Securebits: 00/0x0/1'b0
# secure-noroot: no (unlocked)
# secure-no-suid-fixup: no (unlocked)
# secure-keep-caps: no (unlocked)
# secure-no-ambient-raise: no (unlocked)
# uid=1001(user1)
# gid=1001(user1)
# groups=1001(user1)

capsh --decode=0000000000000001
# Вывод:
# 0x0000000000000001=cap_chown
```

Для исследования и конструирования наборов привилегий предназначена команда capsh. Системные вызовы capget и capset позволяют процессу манипулировать собственными векторами привилегий.

## Привилегии файла

Привилегии также можно связать с исполняемым файлом с помощью команды setcap. Привилегии файла хранятся в его расширенных атрибутах в пространстве security.capability. Запись в этот расширенный атрибут требует наличия привилегии CAP_SETFCAP.

Суперпозиция привилегий исполняемого файла и привилегий вызывающего процесса определяет привилегии процесса после выполнения системного вызова execve.

Существует три набора привилегий файла:

- разрешенный набор (permitted) — эти привилегии автоматически разрешаются процессу, независимо от наследуемых привилегий процесса;

- наследуемый набор (inheritable) — логически перемножается с наследуемым набором процесса (операция логического «И»), чтобы определить, какие наследуемые привилегии должны быть включены в разрешенном наборе процесса после вызова execve;

- эффективный бит (effective). Если этот бит установлен, то во время выполнения вызова execve все новые разрешенные привилегии процесса также поднимаются в векторе эффективных привилегий. Если этот бит не установлен, то после execve никаких новых разрешенных привилегий нет в новом эффективном наборе.

Во время выполнения вызова execve ядро вычисляет новые привилегии процесса по следующему алгоритму:

```bash
P'(ambient)     = (файл привилегированный) ? 0 : P(ambient)
P'(permitted)   = (P(inheritable) & F(inheritable)) | (F(permitted) & P(bounding)) | P'(ambient)
P'(effective)   = F(effective) ? P'(permitted) : P'(ambient)
P'(inheritable) = P(inheritable) [не изменяется]
P'(bounding)    = P(bounding) [не изменяется]
```


где P() – привилегии процесса до вызова execve; P'() – привилегии процесса после вызова execve; F() – привилегии исполняемого файла.

Относительно механизма привилегий программы можно разделить на две группы:
- программы, использующие привилегии, которые скомпилированы с библиотекой libcap (можно посмотреть с помощью команды ldd);
- программы, не использующие механизм привилегий (capability-dumb).


Рассмотрим привилегии исполняемого файла на примере команды cat. Пусть обычный пользователь попытается вывести на экран содержимое файла /etc/shadow, в котором хранятся хэши паролей пользователей, и который доступен только пользователю root:

```bash
whereis -b cat
# Вывод:
# cat: /usr/bin/cat

ldd /usr/bin/cat
# Вывод:
# linux-vdso.so.1 (0x00007ffc48c74000)
# libc.so.6 => /lib64/libc.so.6 (0x00007f5304859000)
# /lib64/ld-linux-x86-64.so.2 (0x00007f5304a4a000)

cat /etc/shadow
# Вывод:
# cat: /etc/shadow: Permission denied
```

Видно, что в выводе команды ldd отсутствует библиотека libcap. Это означает, что программа cat не умеет управлять своими привилегиями, т.е. разработчик программы cat не использовал API библиотеки libcap для обращения к механизму привилегий.

Создадим копию программы cat и с помощью команды setcap установим для нее привилегию cap_dac_read_search. Так как cat является capability-dumb-программой, то необходимо установить оба набора привилегий (=pe) у исполняемого файла: разрешенный (p) и эффективный (e). Если бы программа cat умела управлять своими привилегиями, то было бы достаточно установить только разрешенный (p) набор привилегий. Команда getcap показывает, что привилегия установлена.

```bash 
cp /usr/bin/cat .

sudo setcap "cap_dac_read_search=ep" cat

getcap ./cat
# Вывод:
# ./cat = cap_dac_read_search+ep

./cat /etc/shadow | head -n 1
# Вывод:
# root:!::0:99999:7:::
```

Теперь обычный пользователь может прочитать содержимое любого файла в системе, независимо от установленных для этого файла дискреционных прав доступа, т.е. может обходить механизм DAC по чтению.


# Допуск

1. Как запустить программу в фоновом режиме?

    - `&` - в конце команды используется для запуска этой команды в фоновом режиме. Когда команда выполняется в фоне, она не блокирует терминал.
    - `while true; do printf "AAA %d " $$ >> ~/test.out; sleep 1; done &`
    В данной команде:

    - `./your_program &`

    - приостанавливает выполнение `Ctrl+z` |  `bg` background - чтобы запустить в фоновом режиме  | `fg` foreground - продолжить выполнение приостановленного процесса | `jobs` | `ps j`


2. Что такое сигналы и зачем они нужны?

    - сигналы - это механизм коммуникации между процессами или ядром операционной системы и процессами. Сигналы используются для управления жизненным циклом процессов, обработки ошибок, обмена информацией между процессами и реагирования на определенные события. 
    Сигналы предоставляют эффективный способ управления и контроля за выполнением процессов в операционных системах UNIX-подобных системах. Когда процесс получает сигнал, он может либо игнорировать его, либо выполнить предопределенное действие, либо вызвать обработчик сигнала.

3. Какие системные вызовы используются для создания нового процесса?

    - В Unix-подобных операционных системах для создания нового процесса используется системный вызов fork(). Этот вызов создает точную копию текущего процесса, называемого родительским, включая его код, данные, переменные окружения и открытые файловые дескрипторы. После успешного выполнения fork() возвращается два различных значения:
    exec() совместно с fork() 
    Функция system() в стандартной библиотеке C позволяет выполнить команду в оболочке. 




4. Что такое привилегии и для чего они нужны?

    - Привилегии (capabilities) в контексте операционных систем — это системный механизм, предоставляющий более гибкий и мелкозернистый контроль над разрешениями и правами доступа, чем традиционная система суперпользователя (root) в Unix-подобных операционных системах.

    - Традиционный подход предоставляет полные права суперпользователя всем процессам, запущенным от его имени. Это создает риск воплощения (privilege escalation), так как любой компрометированный процесс с правами суперпользователя может представлять серьезную угрозу для системы.

    - Привилегии были введены для решения этой проблемы. Они позволяют расширенный контроль над возможностями процессов, путем разделения традиционных прав суперпользователя на более мелкие и конкретные привилегии. 

    - Использование привилегий обеспечивает более гибкую систему управления правами и уменьшает риск безопасности, предоставляя процессам только необходимые права. Это особенно важно в современных высокозащищенных средах, где минимизация привилегий помогает снизить возможность успешных атак и ограничивает потенциальный вред от компрометации.

5. Что такое зомби-процессы?

    - Зомби-процессы — это процессы , которые завершили свою работу, но еще не были полностью удалены из таблицы процессов. Эти процессы не выполняют кода, но оставляют свою запись в системной таблице процессов до тех пор, пока родительский процесс не запросит статус завершения своего дочернего процесса.

    - Когда процесс завершается, он переходит в состояние "зомби" до тех пор, пока его родительский процесс не вызовет системный вызов wait() или waitpid(), чтобы получить информацию о статусе завершенного процесса. После того как родительский процесс получит этот статус, зомби-процесс полностью удаляется из системной таблицы процессов, и все связанные с ним ресурсы освобождаются.

    - Зомби-процессы не используют ресурсы системы, так как они уже завершили свою работу, но их наличие может сигнализировать о том, что родительский процесс не выполнил необходимые шаги по удалению завершенных дочерних процессов. Если зомби-процессов становится слишком много, это может привести к исчерпанию системных ресурсов, поэтому важно, чтобы родительские процессы регулярно вызывали wait() или waitpid() для удаления завершенных процессов.




## просто
Разрешите рассказать вам о каждой из этих команд:

1. `ps`: Команда `ps` используется для вывода информации о текущих процессах в операционной системе. Она показывает список процессов, запущенных в системе, их идентификаторы (PID), статусы и другую информацию, такую как использование ресурсов и связи между процессами.

2. `top`: Команда `top` позволяет отслеживать активность процессов в реальном времени. Она выводит динамически обновляемую таблицу, в которой отображается список процессов, их PID, использование процессора, память и другие системные ресурсы. `top` также позволяет выполнять различные операции, такие как сортировка процессов по различным параметрам или отправка сигналов процессам.

3. `pgrep`: Команда `pgrep` используется для поиска процессов по их имени или другим атрибутам и вывода соответствующих идентификаторов процессов (PID). Она облегчает поиск и идентификацию процессов для дальнейшей обработки или взаимодействия с ними.

4. `pstree`: Команда `pstree` позволяет визуализировать иерархию процессов в виде дерева. Она отображает связи между процессами, включая родительские и дочерние процессы, что помогает в понимании структуры работы процессов в системе.

5. `w`: Команда `w` отображает информацию о текущих пользователях системы и их активности. Она показывает список вошедших пользователей, их терминалы, время входа, загрузку системы и текущие процессы, связанные с каждым пользователем.

6. `uptime`: Команда `uptime` отображает информацию о текущем времени работы системы, загрузке и средней загрузке процессора за последнюю минуту, пять минут и пятнадцать минут.

7. `jobs`: Команда `jobs` используется в интерактивной оболочке (например, в Bash) для отображения списка активных заданий (процессов), которые были запущены в фоновом режиме или приостановлены.

8. `fg` и `bg`: Команды `fg` и `bg` используются для работы с заданиями в интерактивной оболочке. `fg` переводит приостановленное или фоновое задание в передний план (foreground), а `bg` возобновляет выполнение приостановленного задания в фоновом режиме (background).

9. `kill`: Команда `kill` используется для отправки сигнала процессу или группе процессов. Она позволяет контролировать выполнение процессов и взаимодействовать с ними, например, для прерывания выполнения процесса или запроса завершения.

10. `killall` и `pkill`: Команды `killall` и `pkill` используются для отправки сигналов процессам по их имени или другим атрибутам. `killall` отправляет сигналы всем процессам с указанным именем, а `pkill` позволяет более гибко выбирать процессы для отправки сигналов, используя шаблоны или другие атрибуты.

11. `trap`: Команда `trap` используется для установки обработчиков сигналов в скриптах оболочки. Она позволяет определить действия, которые должны быть выполнены при получении определенного сигнала операционной системой или пользователем. Например, можно использовать `trap` для обработки сигнала завершения (`SIGINT`) и выполнения определенных действий перед выходом из скрипта.

12. `getcap` и `setcap`: Команды `getcap` и `setcap` используются для управления возможностями исполнения (capabilities) исполняемых файлов в системе Linux. Вместо того чтобы предоставлять полные привилегии root пользователю или процессу, возможности исполнения позволяют ограничить доступные привилегии на более гранулярном уровне. `getcap` позволяет просматривать возможности исполнения для файла, а `setcap` позволяет устанавливать или изменять возможности исполнения для файла.

Это лишь краткое описание каждой из команд, и они имеют множество дополнительных параметров и возможностей. Рекомендуется обратиться к документации или выполнить команду с флагом `--help` для получения более подробной информации о каждой команде.
