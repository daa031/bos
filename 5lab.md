# Лабораторная работа "Управление процессами. Capabilities"

Команды, изучаемые в лабораторной работе: `ps`, `top`, `pgrep`, `pstree`, `w`, `uptime`, `jobs`, `fg`, `bg`, `kill`, `killall`, `pkill`, `trap`, `getcap`, `setcap`.


## Процессы

### Команда `ps` {process status}

### Флаги:
---
--- 


- `-e` - {everyone} отображает информацию о всех процессах на системе, включая процессы всех пользователей.
```bash
    PID TTY          TIME CMD
      1 ?        00:00:01 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
```
`PID` - {Process ID} (идентификатор процесса)- уникальный числовой идентификатор процесса.

`TTY` - указывает на терминал (tty), к которому привязан процесс. ? - процесс не связан с каким-либо терминалом.

`TIME` - Этот столбец показывает общее количество центрального процессорного времени, затраченного процессом с момента его запуска. Время, в течение которого процесс использовал процессор.

`CMD` - команда или имя исполняемого файла, который был запущен как процесс. процесс systemd, который является первым процессом, запускаемым при загрузке системы.

---
--- 

- `-l` - {long} подробный вывод (PID (идентификатор процесса), PPID (идентификатор родительского процесса), статус процесса, UID, CPU использование).

```bash
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     830     806  0  80   0 -  3193 do_wai pts/0    00:00:00 su
4 S     0     834     830  0  80   0 -  1261 do_wai pts/0    00:00:00 bash
4 R     0    1408     834  0  80   0 -  1890 -      pts/0    00:00:00 ps
```
`F` - флаги состояния процесса 

`S` - статус процесса (`R`-Running; `S`-Sleeping; `D`-Disk sleep (в ожидании диска); `T`-Stopped(приостановлен); `Z` - Zombie (зомби): Этот флаг указывает на то, что процесс завершил свою работу, но его запись в системной таблице процессов еще не была удалена. Зомби-процессы обычно ожидают, чтобы их родительский процесс прочитал код завершения и завершил их запись.I - Idle (бездействие):)

`UID` - идентификатор пользователя

`PPID` - идентификатор родительского процесса

`C` -  процент использования CPU, который занимает процесс.

`PRI` - содержит приоритет процесса.

`NI` -  значение "nice", которое влияет на приоритет процесса. Значение "0" означает нейтральный приоритет.

`ADDR` - указывает на адрес памяти процесса

`SZ` -  представляет размер процесса в килобайтах.

`WCHAN` - указывает на "wait channel", то есть на то, что процесс ожидает в данный момент.


--- 
--- 


- `-y` - {TTY} включает в выводе информацию о столбце "TTY" (терминал), который указывает, к какому терминалу привязан процесс. Если процесс не связан с каким-либо терминалом, поле будет пустым.

Столбец "RSS" в выводе команды ps -ly обозначает "Resident Set Size" (размер активной части памяти), и представляет собой объем физической оперативной памяти (RAM), который использует данный процесс в данный момент. Этот столбец показывает, сколько памяти занимает процесс, чтобы выполнять свои задачи.

---
---

- `-f` - {full} предоставляет полное описание процесса, включая информацию о командной строке запуска процесса, а также полный список атрибутов процесса.

- `-F` - {Full-format} предоставляет еще больше информации о процессах, включая дополнительные атрибуты, такие как UID, GID, время запуска и другие.



### синтаксис BSD
```bash
  $ ps ax
  $ ps axu
```
Используются для вывода информации о всех процессах в системе, включая процессы, не связанные с терминалом (`a`), и процессы для всех пользователей (`x`). То есть, комбинация ps ax используется для вывода списка процессов на системе без фильтрации по терминалу или пользователю. опция `u` в синтаксисе BSD используется для вывода более подробной информации о процессах, включая информацию о пользователе, который запустил процесс, процент использования CPU и памяти, время запуска и другие атрибуты. 


### Информация обо всех процессах в системе в виде дерева:

Эти команды выведут информацию о процессах в виде дерева, показывая связи между процессами и их родителями:
```bash
  $ ps -ejH
```
- `e` - Опция, которая отображает все процессы, включая процессы других пользователей.
- `j` - Опция, которая выводит дополнительную информацию о процессах, включая PPID (родительский процесс) и PGID (группа процессов).
- `H` - Опция, которая выводит информацию в виде дерева процессов, показывая связи между процессами и их родителями.


```bash
  $ ps axjf
```
- `a` - Опция, которая отображает все процессы (аналогично опции -e в синтаксисе BSD).
- `x` - Опция, которая выводит процессы, не связанные с терминалом (аналогично опции -x в синтаксисе BSD).
- `j` - Опция, которая выводит дополнительную информацию о процессах, включая PPID (родительский процесс) и PGID (группа процессов).
- `f` - Опция, которая выводит информацию о процессах в виде дерева процессов.


### Информация о легковесных процессах:
```bash
  $ ps -eLf
  $ ps axms
```
- `-e` - Опция, которая отображает все процессы, включая процессы других пользователей.
- `-L` - Опция, которая отображает информацию о легковесных процессах (потоках) внутри каждого процесса. Легковесные процессы (потоки) могут быть частью многозадачных процессов.
Эта команда покажет информацию о легковесных процессах, включая их идентификаторы, приоритеты, состояния и другие атрибуты в контексте каждого родительского процесса.
- `f` используется для вывода информации о процессах в виде дерева процессовю

- `a` - Опция, которая отображает все процессы (аналогично опции -e в синтаксисе BSD).
- `x` - Опция, которая выводит процессы, не связанные с терминалом (аналогично опции -x в синтаксисе BSD).
- `m` - Опция, которая отображает информацию о легковесных процессах (потоках) внутри каждого процесса.
- `s` - представляет состояние (state) каждого легковесного процесса. 

### Атрибуты безопасности процессов

- `ps -eo euser,ruser,suser,fuser,f,comm,label` - используется для вывода информации о процессах с различными атрибутами, такими как пользователь, реальный пользователь, запускающий пользователь, список файлов, флаги состояния процесса, имя команды и метка безопасности. 

`-eo`: Эта опция указывает формат вывода для ps. В данном случае, `-e` означает, что будут выводиться все процессы, и `-o` означает, что мы определяем пользовательский формат вывода.

`euser`: пользователь от имени которого выполняется процесс.

`ruser`: пользователь, который запустил процесс.

`suser`: пользователь, от имени которого был установлен субъект безопасности процесса.

`fuser`: пользователь, от имени которого выполняется процесс файловой блокировки.

`f`: Этот атрибут предоставляет информацию о флагах состояния процесса.

`comm`: имя команды (программы), которая выполняется процессом.

`label`: информация о метке безопасности процесса.

---
---

- `ps axZ`
  
---
---

- `ps -eM`




### Информация о процессах, выполняющихся от имени пользователя root (real & effective ID), в пользовательском формате:

- `ps -U root -u root u`

`-U root`: Это опция, которая фильтрует процессы только для указанного пользователя "root". 
`u` - формат вывода информации о процессах

### Информация о процессах в пользовательском формате:

-  `ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm`

`tid` - выводит идентификатор потока (TID)

`class` - класс планировщика процесса.

`rtprio` -  приоритет в реальном времени (если применимо).

`ni` -  приоритет процесса (приоритет "nice").

`pri` -  общий приоритет процесса.

`psr`- номер процессора, на котором процесс выполняется.

`pcpu` -  процент использования центрального процессора (CPU) процессом.

`stat` -  остояние процесса (например, "R" для выполнения, "S" для ожидания и так далее).

`wchan` -  Этот атрибут выводит информацию о точке ожидания, где процесс ожидает (до 14 символов).

`comm` -  имя команды (программы), которую выполняет процесс.

---
---

-  `ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm`

`ax`: Опция -a означает, что будут отображены все процессы, и -x означает, что будут включены процессы, не связанные с терминалом.

`euid`: эффективный идентификатор пользователя (effective user ID) процесса.

`ruid`: реальный идентификатор пользователя (real user ID) процесса.

`sess`:  идентификатор сессии процесса.



---
---

-  `ps -Ao pid,tt,user,fname,tmout,f,wchan`

`-A`: будут отображены все процессы на системе.

`tt`:информацию о терминале, к которому привязан процесс.

`user`: имя пользователя, от имени которого выполняется процесс.

`fname`: выводит имя исполняемой команды (программы), которую выполняет процесс.

`tmout`: нформацию о таймауте процесса (если применимо).

`f`: от атрибут выводит флаги состояния процесса.

`wchan`: выводит информацию о точке ожидания, где процесс ожидает.


### Только идентификаторы процессов с именем systemd:
- `ps -C systemd -o pid=`


### только имя процесса с идентификатором номер:

- `ps -q номер -o comm=`

## Выполнение процесса в основном и фоновом режимах

1. 
2. ` ( while true; do printf "AAA %d " $$ >> ~/test.out; sleep 1; done ) `
3. `  $ tail -f ~/test.out`
4. `  $ Ctrl+z`
5. 
```bash
[daa@localhost 5lab]$ jobs
[1]+  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[daa@localhost 5lab]$ ps j
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
    805     806     806     806 pts/0       2040 Ss    1000   0:00 -bash
   1506    1507    1507    1507 pts/1       2147 Ss    1000   0:00 -bash
   1507    2036    2036    1507 pts/1       2147 T     1000   0:00 -bash
   2036    2138    2036    1507 pts/1       2147 T     1000   0:00 sleep 1
   1507    2147    2147    1507 pts/1       2147 R+    1000   0:00 ps j
[daa@localhost 5lab]$ bg
[1]+ ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done ) &
[daa@localhost 5lab]$ jobs
[1]+  Running                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done ) &
[daa@localhost 5lab]$ ps j
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
    805     806     806     806 pts/0       2040 Ss    1000   0:00 -bash
   1506    1507    1507    1507 pts/1       2183 Ss    1000   0:00 -bash
   1507    2036    2036    1507 pts/1       2183 S     1000   0:00 -bash
   2036    2182    2036    1507 pts/1       2183 S     1000   0:00 sleep 1
   1507    2183    2183    1507 pts/1       2183 R+    1000   0:00 ps j

```
6. 
```bash
[daa@localhost 5lab]$  ( while true; do printf "UUU %d " $$ >> test.out; sleep 1; done ) &
[2] 2467
```
7. 
```bash
[daa@localhost 5lab]$ jobs
[1]-  Running                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done ) &
[2]+  Running                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done ) &

```
8. 
```bash
[daa@localhost 5lab]$ fg 1
( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
^C
[daa@localhost 5lab]$ jobs
[2]+  Stopped                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
[daa@localhost 5lab]$ fg 2
( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
^C
[daa@localhost 5lab]$ jobs
[daa@localhost 5lab]$ 
```

## Посылка сигналов процессам

1. 

2. 
```bash
[root@localhost 5lab]# ( while true; do printf "AAA %d " $$ >> test.out; sleep 1; done ) &
[1] 2931
[root@localhost 5lab]# ( while true; do printf "UUU %d " $$ >> test.out; sleep 1; done ) &
[2] 2940
[root@localhost 5lab]# jobs 
[1]-  Running                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done ) &
[2]+  Running                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done ) &
[root@localhost 5lab]# ps j
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
      1     710     710     710 tty1         710 Ss+      0   0:00 /sbin/agetty -o -p -- \u --noclear - linux
    806     830     830     806 pts/0       2967 S        0   0:00 su -
    830     834     834     806 pts/0       2967 S        0   0:00 -bash
    834    2931    2931     806 pts/0       2967 S        0   0:00 -bash
    834    2940    2940     806 pts/0       2967 S        0   0:00 -bash
   2931    2965    2931     806 pts/0       2967 S        0   0:00 sleep 1
   2940    2966    2940     806 pts/0       2967 S        0   0:00 sleep 1
    834    2967    2967     806 pts/0       2967 R+       0   0:00 ps j

```
3. 
```bash
tail -f test.out
```
4. 
```bash
[root@localhost 5lab]# kill -SIGSTOP %1

[1]+  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[root@localhost 5lab]# jobs 
[1]+  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[2]-  Running                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done ) &

```
5. 
```bash
[root@localhost 5lab]# kill -SIGSTOP %2

[2]+  Stopped                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
[root@localhost 5lab]# jobs
[1]-  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[2]+  Stopped                 ( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
```
6. 
```bash
[root@localhost 5lab]# fg
( while true; do
    printf "UUU %d " $$ >> test.out; sleep 1;
done )
^C
[root@localhost 5lab]# jobs
[1]+  Stopped                 ( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
[root@localhost 5lab]# fg
( while true; do
    printf "AAA %d " $$ >> test.out; sleep 1;
done )
^C
[root@localhost 5lab]# jobs
[root@localhost 5lab]# 
```

## Изучение команд trap и sleep 

- `trap` - озволяет установить обработчик на сигнал. Опция `-l` выводит список сигналов. Опция `-p` выводит установленные обработчики сигналов.

```bash

  $ trap -l
   1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
   6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
  11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
  16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
  21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
  26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
  31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
  38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
  43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
  48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
  53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
  58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
  63) SIGRTMAX-1	64) SIGRTMAX
  
  ```
Запустите дочерний shell и установите обработчик сигнала EXIT (0, который посылается нажатием Ctrl+d).

  ```bash
    $ sh
  sh-4.3$ trap 'echo Завершение работы...; sleep 2' EXIT
  sh-4.3$ trap -p EXIT
  trap -- 'echo Завершение работы...; sleep 2' EXIT
  ```

  Создайте сценарий.
  ```bash
    #!/bin/bash
  declare -i i=0
  trap 'echo "Аварийное завершение..."; exit 1' SIGINT
  while [ $i -lt 100 ]
  do
  	(( i++ ))
  	echo $i
  	sleep 1
  done
  ```
Запустите сценарий.

```bash
  $ chmod +x test-trap.sh
  $ ./test-trap.sh
```
Завершите сценарий. Объясните результаты.

```bash
[root@localhost 5lab]# ./test-trap.sh 
1
2
^CАварийное завершение...
[root@localhost 5lab]# 

```

`trap 'echo "Аварийное завершение..."; exit 1' SIGINT`: Эта строка устанавливает обработчик события SIGINT. При получении сигнала прерывания (Ctrl+C), будет выполнена команда echo "Аварийное завершение...", а затем скрипт завершится с кодом возврата 1.


## Изучение возможностей файловых систем procfs и sysfs 

# ??????????????????????????????????????
1. Изучите содержимое файла /proc/version и сравните с выводом команды uname -a.

```bash
[root@localhost ~]# cat /proc/version 
Linux version 5.14.0-284.11.1.el9_2.x86_64 (mockbuild@iad1-prod-build001.bld.equ.rockylinux.org) (gcc (GCC) 11.3.1 20221121 (Red Hat 11.3.1-4), GNU ld version 2.35.2-37.el9) #1 SMP PREEMPT_DYNAMIC Tue May 9 17:09:15 UTC 2023
```

```bash
[root@localhost ~]# uname -a
Linux localhost.localdomain 5.14.0-284.11.1.el9_2.x86_64 #1 SMP PREEMPT_DYNAMIC Tue May 9 17:09:15 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux
[root@localhost ~]# 
```
# ??????????????????????????????????????????????????????????????????????????????????????????????????
2. Изучите и сравниет содержимое файлов /proc/meminfo и /sys/devices/system/node/node0/meminfo, и вывод команды free.

- `/proc/meminfo`: 
```bash 
```
- `/sys/devices/system/node/`: 
```bash
```
- `free`

3. Изучите содержимое файла /proc/cpuinfo. Определите количество ядер.

```bash
cpu cores: 1 указывает на количество физических ядер.
siblings: 1 указывает на количество потоков (гиперпотоков).
```
//будет меняться если дат больше ядер в VB

4. Изучите содержимое файла /proc/uptime и сравните с выводом команды uptime. 

```bash
[daa@localhost ~]$ cat /proc/uptime
96.12 179.89
[daa@localhost ~]$ uptime
 01:20:49 up 1 min,  1 user,  load average: 0.05, 0.03, 0.01
[daa@localhost ~]$ 
```
(1)время с момента последней загрузки системы. (2) Это время отражает периоды, когда система была неактивной, и процессоры были в состоянии простоя.
01:20:49: Текущее время.
up 1 min: Время работы системы: 3 дня, 2 часа и 25 минут.
1 user: Количество активных пользователей в данный момент.
load average: 0.05, 0.03, 0.01: Средняя загрузка за последние 1, 5 и 15 минут соответственно.


# ???????????????????????????????????????????????????????????????????????????????? почему разные 1377 и 817
5. Изучите специальную символьную ссылку /proc/self, которая указывает на подкаталог текущего процесса. В переменной $ хранится PID текущего процесса. Объясните результаты.

```bash
[daa@localhost ~]$ echo $$
817
[daa@localhost ~]$ ls -l /proc/self
lrwxrwxrwx. 1 root root 0 Nov 10 01:20 /proc/self -> 1377
[daa@localhost ~]$ ls -ld /proc/$$
dr-xr-xr-x. 9 daa daa 0 Nov 10 01:20 /proc/817
[daa@localhost ~]$ 
```
- `$$` - это встроенная переменная, представляющая идентификатор текущего исполняемого процесса. 

- `/proc/self`- является специальной символьной ссылкой, которая всегда указывает на каталог /proc/<PID>/, где <PID> - это идентификатор текущего процесса (Process ID) в момент выполнения команды. Иными словами, /proc/self - это символьная ссылка, которая динамически заменяется на каталог, соответствующий PID процесса, выполняющего команду.

- `ls -ld /proc/$$` - Показывает атрибуты каталога /proc/3203, где 3203 - это PID текущего процесса. Этот каталог представляет собой директорию с информацией о текущем процессе, такой как файлы cmdline, status, maps, и другие. 


# ????????????????????????????????????????????????????????????????????????????????
6. Изучите содержимое файла /proc/PID_процесса/stat. Формат вывода можно посмотреть в исходном коде ядра Linux в файле /fs/proc/array.c в функции do_task_stat().

```bash
  $ read pid tcomm state other < /proc/$$/stat
  $ echo "Процесс $pid $tcomm находится в состоянии $state"
  Процесс 3203 (bash) находится в состоянии R

```


## Работа процесса с файлами

1. Изучите различные формы обращения к файловым дескрипторам и потокам stdin, stdout, stderr.
```bash
[daa@localhost ~]$ ls -l /dev/std*
lrwxrwxrwx. 1 root root 15 Nov 10 01:20 /dev/stderr -> /proc/self/fd/2
lrwxrwxrwx. 1 root root 15 Nov 10 01:20 /dev/stdin -> /proc/self/fd/0
lrwxrwxrwx. 1 root root 15 Nov 10 01:20 /dev/stdout -> /proc/self/fd/1
[daa@localhost ~]$ ls -l /dev/fd/
total 0
lrwx------. 1 daa daa 64 Nov 10 02:40 0 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 02:40 1 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 02:40 2 -> /dev/pts/0
lr-x------. 1 daa daa 64 Nov 10 02:40 3 -> /proc/1467/fd
```
- `/dev/stderr` - Это символьная ссылка, представляющая собой стандартный вывод ошибок (stderr). В Linux, /dev/stderr - это ссылка на файловый дескриптор, используемый для записи сообщений об ошибках.
- `/proc/self` - Это специальная символьная ссылка в Linux, которая всегда указывает на текущий процесс. В данном случае, /proc/self указывает на информацию о текущем процессе.
- `/fd/2` - В Linux, /proc/self/fd/ содержит символьные ссылки на открытые файловые дескрипторы текущего процесса, и каждая такая ссылка представляет собой файловый дескриптор.

Таким образом, /dev/stderr фактически указывает на файловый дескриптор 2 текущего процесса, который представляет собой стандартный вывод ошибок. При записи в /dev/stderr, данные фактически попадают в файловый дескриптор 2 и выводятся в стандартный вывод ошибок процесса.

- `/dev/pts/0`: Это устройство псевдотерминала с индексом 0. Когда пользователь входит в систему в текстовом режиме или открывает терминал в графическом интерфейсе, система создает псевдотерминал и связывает его с терминалом пользователя. /dev/pts/0 будет использоваться для ввода и вывода этого терминала.Когда вы видите, что файловые дескрипторы (0, 1, 2) направлены в /dev/pts/0, это означает, что стандартный ввод, вывод и вывод ошибок направлены на терминал, связанный с этим псевдотерминалом. В этом терминале пользователь может взаимодействовать с командной оболочкой и другими программами, используя текстовый интерфейс.

-  `3 -> /proc/1467/fd`: Эта строка описывает символьную ссылку 3, указывающую на файловый дескриптор 3. Однако, в отличие от предыдущих строк, она не указывает на терминал. Вместо этого, файловый дескриптор 3 направлен на каталог файловых дескрипторов процесса с PID 1467, который скорее всего представляет собой другой процесс в системе.

# ????????????????????????????????????????????????????????????????????????????????не понял  отличия /proc/self/fd от /dev/fd/ 
2. Изучите список открытых файлов процесса. Определите потоки stdin, stdout, stderr.
```bash
[daa@localhost ~]$ ls -l /proc/self/fd
total 0
lrwx------. 1 daa daa 64 Nov 10 03:06 0 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 03:06 1 -> /dev/pts/0
lrwx------. 1 daa daa 64 Nov 10 03:06 2 -> /dev/pts/0
lr-x------. 1 daa daa 64 Nov 10 03:06 3 -> /proc/1684/fd
```

Таким образом, ls -l /dev/fd/ предоставляет более общую информацию о файловых дескрипторах в системе, в то время как ls -l /proc/self/fd фокусируется на файловых дескрипторах текущего процесса.

# ????????????????????????????????????????????????????????????????????????????????почему лабы с не кидают ошбку в /tmp/ls.err
3. Перенаправьте потоки stdout и stderr в файлы. Объясните результаты.
```bash
[root@localhost 4lab]# ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err
[root@localhost 4lab]# cat /tmp/ls.out 
total 0
lrwx------. 1 root root 64 Nov 10 03:24 0 -> /dev/pts/0
l-wx------. 1 root root 64 Nov 10 03:24 1 -> /tmp/ls.out
l-wx------. 1 root root 64 Nov 10 03:24 2 -> /tmp/ls.err
lr-x------. 1 root root 64 Nov 10 03:24 3 -> /proc/2633/fd
[root@localhost 4lab]# 
```
# ???????????????????????????????????????????????????????????????????????????????? НЕ ПОНЯЛ ЧТО ПРОИЗОШЛО
4. Перенаправьте поток stdin. Объясните права доступа.

```bash
[root@localhost 4lab]# ls -l /proc/self/fd < /root/4lab/new > /tmp/ls.in
[root@localhost 4lab]# cat /tmp/ls.in 
total 0
lr-x------. 1 root root 64 Nov 10 03:32 0 -> /root/4lab/new
l-wx------. 1 root root 64 Nov 10 03:32 1 -> /tmp/ls.in
lrwx------. 1 root root 64 Nov 10 03:32 2 -> /dev/pts/0
lr-x------. 1 root root 64 Nov 10 03:32 3 -> /proc/3144/fd
```

# Исследование взаимодействия параллельных процессов через каналы
